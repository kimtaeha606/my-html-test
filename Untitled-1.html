<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ë°¥ê³µêµ¬ | ë¹ ë¥¸ 4ë¬¸í•­ ì„¤ë¬¸</title>
  <style>
    /* === ì¬ë£Œ ì¸ë„¤ì¼ === */
.thumb{
  width:32px;
  height:32px;
  border-radius:8px;
  object-fit:cover;
  border:1px solid var(--border);
  margin-right:8px;
}

    :root{
      --carrot:#FF6F0F; --carrot-weak:#FFF1E8;
      --bg:#FFFDFC; --card:#ffffff; --text:#1F2937; --muted:#6B7280; --border:#E5E7EB;
      --radius:16px; --shadow:0 10px 24px rgba(17,24,39,.08);
    }
    *{box-sizing:border-box}
    html,body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,"Noto Sans KR",Apple SD Gothic Neo,Segoe UI,Roboto,sans-serif}
    .wrap{max-width:880px;margin:0 auto;padding:24px}
    header{position:sticky;top:0;background:#fff;border-bottom:1px solid var(--border);z-index:20}
    header .inner{max-width:880px;margin:0 auto;padding:14px 24px;display:flex;gap:12px;align-items:center}
    .logo{display:flex;gap:10px;align-items:center;font-weight:700}
    .logo .dot{width:12px;height:12px;background:var(--carrot);border-radius:50%}

    .card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);padding:24px}
    .progress{height:8px;background:var(--carrot-weak);border-radius:999px;overflow:hidden}
    .bar{height:100%;width:0;background:var(--carrot);transition:width .35s ease}

    .q-title{font-size:22px;font-weight:800;margin:6px 0 14px}
    .q-help{color:var(--muted);font-size:14px;margin:-4px 0 14px}

    .options{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:12px}
    .opt{border:1px solid var(--border);border-radius:12px;padding:14px;display:flex;gap:10px;align-items:center;cursor:pointer;transition:transform .06s ease,border-color .12s ease,box-shadow .12s ease}
    .opt:hover{transform:translateY(-1px);box-shadow:0 4px 14px rgba(17,24,39,.06)}
    .opt input{accent-color:var(--carrot)}

    .inline{display:flex;gap:10px;align-items:center}
    .hidden{display:none}

    .nav{display:flex;justify-content:space-between;margin-top:18px;gap:12px;align-items:center}
    .nav.final-step{flex-direction:column;align-items:stretch}
    .nav.final-step #prevBtn{align-self:flex-start}
    .btn{appearance:none;border:1px solid var(--border);background:#fff;border-radius:10px;padding:12px 16px;font-weight:700;cursor:pointer;transition:transform .06s ease,box-shadow .12s ease}
    .btn.final-action{width:100%;padding:16px 20px;font-size:18px;display:flex;justify-content:center;align-items:center;gap:8px}
    .btn.final-action .emoji{font-size:20px}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .btn.fill{background:var(--carrot);border-color:var(--carrot);color:#fff}

    .pill{display:inline-flex;align-items:center;gap:8px;border:1px solid var(--border);background:#fff;border-radius:999px;padding:8px 12px}

    textarea, input[type="text"], select, input[type="number"]{
      width:100%;padding:12px;border:1px solid var(--border);border-radius:10px;outline:none
    }
    textarea:focus, input:focus, select:focus{border-color:var(--carrot)}

    .summary pre{background:#0F172A;color:#E2E8F0;border-radius:12px;padding:16px;overflow:auto}
    .result-header{display:flex;flex-direction:column;gap:6px;margin-bottom:16px}
    .result-header h2{margin:0;font-size:24px;font-weight:800}
    .result-header p{margin:0;color:var(--muted)}
    .small{font-size:12px;color:var(--muted)}

    /* ====== Cart & Menu Table ====== */
    .section-title{font-size:20px;font-weight:800;margin:22px 0 10px}
    .table{width:100%;border-collapse:separate;border-spacing:0 8px}
    .tr{display:grid;grid-template-columns:2fr 1fr 1fr auto;gap:8px;align-items:center;background:#fff;border:1px solid var(--border);border-radius:12px;padding:10px}
    .th{font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:.04em;margin-bottom:6px}
    .chip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border);border-radius:999px;padding:6px 10px;font-size:12px}
    .icon-btn{border:1px solid var(--border);background:#fff;border-radius:8px;padding:6px 10px;cursor:pointer}
    .icon-btn:hover{box-shadow:0 2px 8px rgba(17,24,39,.08)}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;margin:10px 0}
    .muted{color:var(--muted)}
    
    /* GPT Integration UI Styles */
    .loading-indicator {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--carrot);
      font-weight: 600;
      margin-top: 12px;
    }
    
    .loading-spinner {
      width: 16px;
      height: 16px;
      border: 2px solid var(--carrot-weak);
      border-top: 2px solid var(--carrot);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .status-message {
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      margin-top: 8px;
      display: inline-block;
    }
    
    .status-success {
      background: #dcfce7;
      color: #166534;
      border: 1px solid #bbf7d0;
    }
    
    .status-error {
      background: #fef2f2;
      color: #dc2626;
      border: 1px solid #fecaca;
    }
    
    .status-warning {
      background: #fffbeb;
      color: #d97706;
      border: 1px solid #fed7aa;
    }
    
    .status-info {
      background: #eff6ff;
      color: #2563eb;
      border: 1px solid #dbeafe;
    }
    
    .menu-source-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .menu-source-gpt {
      background: #f0f9ff;
      color: #0369a1;
      border: 1px solid #bae6fd;
    }
    
    .menu-source-local {
      background: #f9fafb;
      color: #6b7280;
      border: 1px solid #e5e7eb;
    }
    
    .truncation-notice {
      background: var(--carrot-weak);
      color: var(--carrot);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 13px;
      margin-top: 8px;
      border: 1px solid #fed7aa;
    }
  </style>
</head>
<body>
  <header>
    <div class="inner">
      <div class="logo"><span class="dot"></span> ë°¥ê³µêµ¬ ì„¤ë¬¸</div>
      <div style="flex:1"></div>
      <div class="pill"><span id="stepLabel">1 / 4</span></div>
    </div>
  </header>

  <main class="wrap">
    <div class="card" style="margin-bottom:12px">
      <div class="progress" aria-hidden="true"><div id="bar" class="bar"></div></div>
    </div>

    <!-- ìŠ¬ë¼ì´ë“œ ì»¨í…Œì´ë„ˆ -->
    <section id="slides" class="card">
      <!-- Q1 ì¸ì›ìˆ˜ -->
      <article class="slide" data-id="people">
        <div class="q-title">1ï¸âƒ£ í•¨ê»˜ ì‹ì‚¬í•  ì¸ì›ì€ ëª‡ ëª…ì¸ê°€ìš”?</div>
        <div class="q-help">1~4ì¸ì€ ë°”ë¡œ ì„ íƒ, 5ì¸ ì´ìƒì€ ì •í™•í•œ ì¸ì›ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.</div>
        <div class="options" role="radiogroup" aria-label="ì¸ì› ì„ íƒ">
          <label class="opt"><input type="radio" name="people" value="1"> 1ì¸ê°€êµ¬</label>
          <label class="opt"><input type="radio" name="people" value="2"> 2ì¸ê°€êµ¬</label>
          <label class="opt"><input type="radio" name="people" value="3"> 3ì¸ê°€êµ¬</label>
          <label class="opt"><input type="radio" name="people" value="4"> 4ì¸ê°€êµ¬</label>
          <label class="opt inline">
            <input type="radio" name="people" value="5+"> 5ì¸ ì´ìƒ
          </label>
        </div>
        <div id="peopleMore" class="hidden" style="margin-top:12px">
          <label class="inline" for="peopleExact">
            ì •í™•í•œ ì¸ì›: <input id="peopleExact" type="number" min="5" max="20" inputmode="numeric" placeholder="5" style="width:120px;margin-left:8px" /> ëª…
          </label>
          <div class="small">ìµœì†Œ 5ëª…, ìµœëŒ€ 20ëª…ê¹Œì§€ ì…ë ¥í•  ìˆ˜ ìˆì–´ìš”.</div>
        </div>
      </article>

      <!-- Q2 ë©°ì¹ ì¹˜ -->
      <article class="slide hidden" data-id="days">
        <div class="q-title">2ï¸âƒ£ ëª‡ ì¼ ì¹˜ë¥¼ ì¥ë°”êµ¬ë‹ˆì— ë‹´ì„ê¹Œìš”?</div>
        <div class="options" role="radiogroup" aria-label="ì¼ìˆ˜ ì„ íƒ">
          <label class="opt"><input type="radio" name="days" value="1"> 1ì¼ì¹˜</label>
          <label class="opt"><input type="radio" name="days" value="2"> 2ì¼ì¹˜</label>
          <label class="opt"><input type="radio" name="days" value="3"> 3ì¼ì¹˜</label>
          <label class="opt"><input type="radio" name="days" value="4"> 4ì¼ì¹˜</label>
          <label class="opt"><input type="radio" name="days" value="5"> 5ì¼ì¹˜</label>
          <label class="opt"><input type="radio" name="days" value="6"> 6ì¼ì¹˜</label>
          <label class="opt"><input type="radio" name="days" value="7"> 7ì¼ì¹˜</label>
        </div>
      </article>

      <!-- Q3 ë¼ë‹ˆ ìŠ¤í‚µ -->
      <article class="slide hidden" data-id="meals">
        <div class="q-title">3ï¸âƒ£ ì§‘ì—ì„œ ì•ˆ ë¨¹ê±°ë‚˜ ê±°ë¥´ì‹œëŠ” ë¼ë‹ˆê°€ ìˆë‹¤ë©´?</div>
        <div class="q-help">ë³µìˆ˜ ì„ íƒì´ ê°€ëŠ¥í•´ìš”. ì—†ìœ¼ë©´ ê±´ë„ˆë›°ì…”ë„ ë©ë‹ˆë‹¤.</div>
        <div class="options" role="group" aria-label="ë¼ë‹ˆ ì„ íƒ">
          <label class="opt"><input type="checkbox" name="skip" value="ì•„ì¹¨"> ì•„ì¹¨</label>
          <label class="opt"><input type="checkbox" name="skip" value="ì ì‹¬"> ì ì‹¬</label>
          <label class="opt"><input type="checkbox" name="skip" value="ì €ë…"> ì €ë…</label>
        </div>
      </article>

      <!-- Q4 ì„ í˜¸ ë©”ë‰´ -->
      <article class="slide hidden" data-id="favorites">
        <div class="q-title">4ï¸âƒ£ ìì£¼ ë¨¹ê±°ë‚˜ ì¢‹ì•„í•˜ëŠ” ë©”ë‰´ê°€ ìˆë‹¤ë©´ ì•Œë ¤ì£¼ì„¸ìš”!</div>
        <textarea id="fav" rows="4" placeholder="ì˜ˆ) ê¹€ì¹˜ë³¶ìŒë°¥, ì œìœ¡ë³¶ìŒ, ë‹­ê°€ìŠ´ì‚´ ìƒëŸ¬ë“œ"></textarea>
        <div class="small" style="margin-top:8px">ì½¤ë§ˆ(,)ë¡œ êµ¬ë¶„í•´ ì—¬ëŸ¬ ê°œ ì…ë ¥í•˜ì…”ë„ ì¢‹ì•„ìš”.</div>
        <div id="favoriteTruncationNotice" class="truncation-notice hidden">
          âš ï¸ ì„ í˜¸ ë©”ë‰´ê°€ 3ê°œë¥¼ ì´ˆê³¼í•˜ì—¬ ì²˜ìŒ 3ê°œë§Œ ì¶”ì²œ ì—”ì§„ìœ¼ë¡œ ì „ì†¡ë©ë‹ˆë‹¤.
        </div>
      </article>

      <!-- ë„¤ë¹„ê²Œì´ì…˜ -->
      <div class="nav">
        <button id="prevBtn" class="btn" disabled>ì´ì „</button>
        <button id="nextBtn" class="btn fill">ë‹¤ìŒ</button>
      </div>
    </section>

    <section id="resultSection" class="card hidden" aria-live="polite" style="margin-top:18px">
      <div class="result-header hidden" id="resultHeader">
        <h2>âœ… ì¥ë°”êµ¬ë‹ˆê°€ ì¤€ë¹„ë˜ì—ˆì–´ìš”!</h2>
        <p>ë§ì¶¤ ë©”ë‰´ì™€ ì¥ë°”êµ¬ë‹ˆë¥¼ ì•„ë˜ì—ì„œ ë°”ë¡œ í™•ì¸í•  ìˆ˜ ìˆì–´ìš”.</p>
      </div>

      <div id="loadingIndicator" class="loading-indicator hidden" role="status" aria-live="polite">
        <div class="loading-spinner" aria-hidden="true"></div>
        <span id="loadingText">ì¥ë°”êµ¬ë‹ˆ ìƒì„± ì¤‘...</span>
      </div>

      <div id="statusMessage" class="hidden"></div>
      <div id="truncationNotice" class="hidden"></div>

      <div class="summary" style="margin-top:16px">
        <div class="pill" style="margin-bottom:12px"><strong>ì‘ë‹µ ìš”ì•½</strong></div>
        <ul id="summary" style="line-height:1.8"></ul>
      </div>

      <div id="resultWrap" class="hidden" style="margin-top:24px">
        <div class="section-title">ğŸ± ì¶”ì²œ ë©”ë‰´</div>
        <div id="menusBox" class="card" style="padding:16px"></div>

        <div class="section-title">ğŸ§º ì¥ë°”êµ¬ë‹ˆ(ì¬ë£Œ í†µí•©)</div>
        <div class="toolbar">
          <input id="cartSearch" type="text" placeholder="ì¬ë£Œ ê²€ìƒ‰(ì˜ˆ: ëŒ€íŒŒ, ë¼ì§€ê³ ê¸°)" style="max-width:260px"/>
        </div>
        <div id="cartBox"></div>
      </div>
    </section>
  </main>

  <!-- ì„¤ë¬¸ ë¡œì§ -->
  <script>
    // ===== ìƒíƒœ =====
    let index = 0; // 0..3 (ì´ 4ë‹¨ê³„)
    const slides = Array.from(document.querySelectorAll('.slide'));
    const bar = document.getElementById('bar');
    const stepLabel = document.getElementById('stepLabel');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const nav = document.querySelector('.nav');

    const FINAL_LABEL_HTML = '<span class="emoji" aria-hidden="true">ğŸ›’</span> ì¥ë°”êµ¬ë‹ˆ ë§Œë“¤ê¸°';

    function totalSteps(){ return slides.length; }

    function slideTo(i){
      slides.forEach((el,idx)=> el.classList.toggle('hidden', idx!==i));
      index = i;
      const step = Math.min(index+1, totalSteps());
      stepLabel.textContent = `${step} / ${totalSteps()}`;
      const pct = Math.min(((index+1)/totalSteps())*100, 100);
      bar.style.width = pct + '%';
      afterSlide();
    }

    function afterSlide(){
      prevBtn.disabled = index===0;
      const isFinal = index===totalSteps()-1;
      if(nav){ nav.classList.toggle('final-step', isFinal); }
      nextBtn.classList.toggle('final-action', isFinal);
      if(isFinal){
        nextBtn.innerHTML = FINAL_LABEL_HTML;
        nextBtn.dataset.originalContent = FINAL_LABEL_HTML;
        nextBtn.setAttribute('aria-label', 'ì¥ë°”êµ¬ë‹ˆ ë§Œë“¤ê¸°');
        renderSummary();
      } else {
        nextBtn.textContent = 'ë‹¤ìŒ';
        nextBtn.setAttribute('aria-label', 'ë‹¤ìŒ ì§ˆë¬¸ìœ¼ë¡œ ì´ë™');
        delete nextBtn.dataset.originalContent;
        nextBtn.dataset.usesGpt = 'false';
      }
      nextBtn.classList.remove('hidden');
    }

    // Q1: 5ì¸ ì´ìƒ ì„ íƒ ì‹œ ìˆ«ì ì…ë ¥ ë…¸ì¶œ
    const peopleRadios = document.querySelectorAll('input[name="people"]');
    const peopleMore = document.getElementById('peopleMore');
    const peopleExact = document.getElementById('peopleExact');
    peopleRadios.forEach(r=>{
      r.addEventListener('change',()=>{
        if(r.value==='5+' && r.checked){
          peopleMore.classList.remove('hidden');
          peopleExact.focus();
        } else if(r.checked){
          peopleMore.classList.add('hidden');
        }
      })
    })

    function getAnswers(){
      let selected = document.querySelector('input[name="people"]:checked');
      let people = null;
      if(selected){
        if(selected.value==='5+'){
          const n = Number(peopleExact.value);
          people = Number.isFinite(n) && n>=5 ? n : null;
        } else {
          people = Number(selected.value);
        }
      }
      const daysSel = document.querySelector('input[name="days"]:checked');
      const days = daysSel ? Number(daysSel.value) : null;
      const skip = Array.from(document.querySelectorAll('input[name="skip"]:checked')).map(x=>x.value);
      const favRaw = document.getElementById('fav').value.trim();
      const favorites = favRaw ? favRaw.split(',').map(s=>s.trim()).filter(Boolean) : [];
      
      // Show truncation notice if needed
      if (favorites.length > 3) {
        GPTUIManager.showTruncationNotice(favorites.length, 3);
      } else {
        GPTUIManager.hideTruncationNotice();
      }
      
      return { people, days, skipMeals: skip, favoriteMenu: favorites };
    }

    function validateCurrent(){
      const id = slides[index].dataset.id;
      const ans = getAnswers();
      if(id==='people'){
        if(ans.people==null){ alert('ì¸ì›ì„ ì„ íƒí•˜ê±°ë‚˜ 5ì¸ ì´ìƒì¼ ê²½ìš° ì •í™•í•œ ì¸ì›ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.'); return false; }
      }
      if(id==='days'){
        if(!ans.days){ alert('ì¼ìˆ˜ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.'); return false; }
      }
      return true;
    }

    function renderSummary(){
      const ans = getAnswers();
      const ul = document.getElementById('summary');
      ul.innerHTML = '';
      
      // Basic info
      const li1 = document.createElement('li');
      li1.textContent = `ì¸ì›: ${ans.people ?? '-'}ëª…`;
      const li2 = document.createElement('li');
      li2.textContent = `ì¼ìˆ˜: ${ans.days ?? '-'}ì¼ì¹˜ (ì´ ì˜ˆìƒ ë¼ë‹ˆ: ${ans.days? ans.days*3 : '-'}ë¼)`;
      const li3 = document.createElement('li');
      li3.textContent = `ê±°ë¥´ëŠ” ë¼ë‹ˆ: ${ans.skipMeals.length? ans.skipMeals.join(', ') : 'ì—†ìŒ'}`;
      const li4 = document.createElement('li');
      li4.textContent = `ì„ í˜¸ ë©”ë‰´: ${ans.favoriteMenu.length? ans.favoriteMenu.join(', ') : 'ì—†ìŒ'}`;
      
      // Add constraint calculation summary if we have valid data
      if (ans.days && typeof MenuConstraintCalculator !== 'undefined') {
        const constraints = {
          days: ans.days,
          skipMeals: ans.skipMeals || [],
          favoriteMenus: ans.favoriteMenu || []
        };
        
        const summary = MenuConstraintCalculator.getConstraintSummary(constraints);
        
        const li5 = document.createElement('li');
        li5.innerHTML = `<strong>ë§ì¶¤ ë©”ë‰´ ê³„íš:</strong> ì €ë… ìŠ¬ë¡¯ ${summary.dinnerSlots}ê°œ, ìµœëŒ€ ë§ì¶¤ ë©”ë‰´ ${summary.maxGPTMenus}ê°œ`;
        
        if (summary.warnings.length > 0) {
          const li6 = document.createElement('li');
          li6.innerHTML = `<span style="color: #f59e0b;">âš ï¸ ${summary.warnings.join(', ')}</span>`;
          [li1,li2,li3,li4,li5,li6].forEach(li=>ul.appendChild(li));
        } else {
          [li1,li2,li3,li4,li5].forEach(li=>ul.appendChild(li));
        }
      } else {
        [li1,li2,li3,li4].forEach(li=>ul.appendChild(li));
      }
      
      // Update submit button text based on GPT integration potential
      const hasFavorites = ans?.favoriteMenu && ans.favoriteMenu.length > 0;
      const skipSet = new Set(ans?.skipMeals || []);
      const needDinner = !skipSet.has("ì €ë…");
      GPTUIManager.updateSubmitButtonForGPT(hasFavorites, needDinner);
      
    }

    nextBtn.addEventListener('click', async ()=>{
      if(!validateCurrent()) return;
      if(index < totalSteps()-1){
        slideTo(index+1);
        return;
      }
      await handleSubmit();
    });

    prevBtn.addEventListener('click', ()=>{
      if(index>0){ slideTo(index-1); }
    });

    document.addEventListener('keydown', (e)=>{
      if(e.key==='Enter'){
        const tag = document.activeElement?.tagName?.toLowerCase();
        if(tag!=='textarea' && tag!=='input'){
          e.preventDefault();
          nextBtn.click();
        }
      }
    });

    // Real-time favorite menu validation
    const favInput = document.getElementById('fav');
    if (favInput) {
      favInput.addEventListener('input', () => {
        const favRaw = favInput.value.trim();
        const favorites = favRaw ? favRaw.split(',').map(s=>s.trim()).filter(Boolean) : [];
        
        if (favorites.length > 3) {
          GPTUIManager.showTruncationNotice(favorites.length, 3);
        } else {
          GPTUIManager.hideTruncationNotice();
        }
      });
    }

    // ì´ˆê¸° ì§„ì…
    slideTo(0);
  </script>

  <!-- GPT API Integration -->
  <script>
    // GPT API Configuration
    const storedBackend = (typeof localStorage !== 'undefined') ? localStorage.getItem('bobgonggu_backend_url') : null;
    const DEFAULT_BACKEND = 'https://bobgonggu-api.bobgonggu.workers.dev';
    const backendBase = (window.BOBGONGGU_API_URL || storedBackend || DEFAULT_BACKEND).replace(/\/$/, '');

    const GPT_CONFIG = {
      apiUrl: `${backendBase}/`,
      healthUrl: `${backendBase}/health`,
      timeout: 20000, // 20ì´ˆ - GPT API ì‘ë‹µ ì‹œê°„ ê³ ë ¤
      maxRetries: 2,
      maxMenus: 3,
      // Circuit breaker configuration
      circuitBreaker: {
        failureThreshold: 5, // Number of failures before opening circuit
        resetTimeout: 300000, // 5 minutes before attempting to close circuit
        monitoringPeriod: 60000 // 1 minute monitoring window
      },
      // Rate limiting configuration
      rateLimit: {
        maxRequestsPerMinute: 10,
        requestWindow: 60000 // 1 minute window
      }
    };

    // Circuit Breaker for GPT API
    class GPTCircuitBreaker {
      constructor(config = GPT_CONFIG.circuitBreaker) {
        this.failureThreshold = config.failureThreshold;
        this.resetTimeout = config.resetTimeout;
        this.monitoringPeriod = config.monitoringPeriod;
        
        this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
        this.failureCount = 0;
        this.lastFailureTime = null;
        this.successCount = 0;
        
        // Track failures in a time window
        this.recentFailures = [];
      }

      async execute(operation) {
        if (this.state === 'OPEN') {
          if (Date.now() - this.lastFailureTime > this.resetTimeout) {
            this.state = 'HALF_OPEN';
            this.successCount = 0;
            console.log('Circuit breaker moving to HALF_OPEN state');
          } else {
            throw new APIError('Circuit breaker is OPEN - GPT API temporarily unavailable', 503);
          }
        }

        try {
          const result = await operation();
          this.onSuccess();
          return result;
        } catch (error) {
          this.onFailure();
          throw error;
        }
      }

      onSuccess() {
        this.failureCount = 0;
        this.recentFailures = [];
        
        if (this.state === 'HALF_OPEN') {
          this.successCount++;
          if (this.successCount >= 2) { // Require 2 successes to close
            this.state = 'CLOSED';
            console.log('Circuit breaker CLOSED - GPT API recovered');
          }
        }
      }

      onFailure() {
        const now = Date.now();
        this.lastFailureTime = now;
        this.recentFailures.push(now);
        
        // Clean old failures outside monitoring period
        this.recentFailures = this.recentFailures.filter(
          time => now - time < this.monitoringPeriod
        );
        
        if (this.recentFailures.length >= this.failureThreshold) {
          this.state = 'OPEN';
          console.log('Circuit breaker OPEN - GPT API temporarily disabled');
        }
      }

      getState() {
        return {
          state: this.state,
          failureCount: this.recentFailures.length,
          lastFailureTime: this.lastFailureTime,
          timeUntilReset: this.state === 'OPEN' 
            ? Math.max(0, this.resetTimeout - (Date.now() - this.lastFailureTime))
            : 0
        };
      }
    }

    // Rate Limiter for GPT API
    class GPTRateLimiter {
      constructor(config = GPT_CONFIG.rateLimit) {
        this.maxRequests = config.maxRequestsPerMinute;
        this.windowMs = config.requestWindow;
        this.requests = [];
      }

      async checkLimit() {
        const now = Date.now();
        
        // Clean old requests outside the window
        this.requests = this.requests.filter(time => now - time < this.windowMs);
        
        if (this.requests.length >= this.maxRequests) {
          const oldestRequest = Math.min(...this.requests);
          const waitTime = this.windowMs - (now - oldestRequest);
          
          throw new APIError(
            `Rate limit exceeded. Please wait ${Math.ceil(waitTime / 1000)} seconds.`, 
            429
          );
        }
        
        this.requests.push(now);
      }

      getStatus() {
        const now = Date.now();
        const recentRequests = this.requests.filter(time => now - time < this.windowMs);
        
        return {
          requestsInWindow: recentRequests.length,
          maxRequests: this.maxRequests,
          windowMs: this.windowMs,
          remainingRequests: Math.max(0, this.maxRequests - recentRequests.length)
        };
      }
    }

    // GPT API Client Class
    class GPTMenuClient {
      constructor() {
        this.requestCount = 0;
        this.circuitBreaker = new GPTCircuitBreaker();
        this.rateLimiter = new GPTRateLimiter();
        this.lastRequestTime = 0;
        this.lastHealthStatus = {
          available: null,
          reason: 'ìƒíƒœ í™•ì¸ ì „',
          status: null,
          timestamp: null
        };
      }

      normalizeSkipMeals(skipMeals) {
        if (!Array.isArray(skipMeals)) return [];
        return skipMeals.map(meal => String(meal)).filter(Boolean);
      }

      async generateMenus(options = {}) {
        const {
          favorites,
          people = 2,
          days = 1,
          maxCount = GPT_CONFIG.maxMenus,
          skipMeals = [],
          includeIngredientPrices = false
        } = options || {};

        if (!favorites || !Array.isArray(favorites) || favorites.length === 0) {
          throw new ValidationError('No favorite menus provided or invalid format', favorites);
        }

        const validatedPeople = this.validateAndNormalizeNumber(people, 'people', 1, 20, 2);
        const validatedDays = this.validateAndNormalizeNumber(days, 'days', 1, 14, 1);
        const validatedMaxCount = this.validateAndNormalizeNumber(maxCount, 'maxCount', 1, GPT_CONFIG.maxMenus, GPT_CONFIG.maxMenus);

        const limitedMenus = favorites
          .slice(0, validatedMaxCount)
          .filter(menu => menu && typeof menu === 'string' && menu.trim())
          .map(menu => menu.trim());

        if (limitedMenus.length === 0) {
          throw new ValidationError('No valid favorite menus after filtering', favorites);
        }

        console.log('ë°±ì—”ë“œë¡œ ì „ì†¡í•  íŒŒë¼ë¯¸í„°:', {
          favorites: limitedMenus,
          people: validatedPeople,
          days: validatedDays,
          skipMeals: this.normalizeSkipMeals(skipMeals)
        });

        try {
          await this.rateLimiter.checkLimit();

          const response = await this.circuitBreaker.execute(async () => {
            return await GPTErrorHandler.withRetry(async () => {
              const payload = {
                favorites: limitedMenus,
                people: validatedPeople,
                days: validatedDays,
                skipMeals: this.normalizeSkipMeals(skipMeals)
              };

              if (includeIngredientPrices) {
                payload.includeIngredientPrices = true;
              }

              return await this.makeApiCall(payload);
            });
          });

          let menus;

          try {
            menus = this.parseResponse(response, validatedPeople);
          } catch (parseError) {
            console.warn('ë°±ì—”ë“œ ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨, ë¡œì»¬ fallback ë©”ë‰´ ìƒì„±', parseError);
            this.requestCount++;
            this.lastRequestTime = Date.now();
            return this.generateFallbackMenusFromFavorites(limitedMenus, validatedPeople);
          }

          if (!menus || menus.length === 0) {
            console.warn('ë°±ì—”ë“œê°€ ìœ íš¨í•œ ë©”ë‰´ë¥¼ ë°˜í™˜í•˜ì§€ ì•ŠìŒ, ë¡œì»¬ fallback ë©”ë‰´ ìƒì„±');
            this.requestCount++;
            this.lastRequestTime = Date.now();
            return this.generateFallbackMenusFromFavorites(limitedMenus, validatedPeople);
          }

          this.requestCount++;
          this.lastRequestTime = Date.now();

          console.log(`GPT API ì„±ê³µ: ${menus.length}ê°œ ë©”ë‰´ ìƒì„±`);
          return menus;

        } catch (error) {
          console.error('ë°±ì—”ë“œ API ì˜¤ë¥˜:', error);

          if (error instanceof NetworkError) {
            console.warn('ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜, ë¡œì»¬ fallback ë©”ë‰´ ìƒì„±');
            this.requestCount++;
            this.lastRequestTime = Date.now();
            return this.generateFallbackMenusFromFavorites(limitedMenus, validatedPeople);
          }

          if (error instanceof APIError || error instanceof ValidationError) {
            throw error;
          }

          throw new APIError(`ë©”ë‰´ ìƒì„± ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: ${error.message}`, 0, error);
        }
      }

      async makeApiCall(payload) {
        return await GPTErrorHandler.withTimeout(async (signal) => {
          try {
            console.log('ë°±ì—”ë“œ API í˜¸ì¶œ ì‹œì‘:', GPT_CONFIG.apiUrl);
            console.log('í˜ì´ë¡œë“œ:', payload);

            const response = await fetch(GPT_CONFIG.apiUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(payload),
              signal
            });

            console.log('ë°±ì—”ë“œ ì‘ë‹µ ìƒíƒœ:', response.status);

            if (!response.ok) {
              let errorData = {};
              let errorMessage = `HTTP ${response.status}`;

              try {
                const contentType = response.headers.get('content-type');
                if (contentType && contentType.includes('application/json')) {
                  errorData = await response.json();
                  errorMessage = errorData.error || errorData.message || errorMessage;
                } else {
                  const textError = await response.text();
                  errorMessage = textError || `${errorMessage}: ${response.statusText}`;
                }
              } catch (parseError) {
                console.warn('ë°±ì—”ë“œ ì˜¤ë¥˜ ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨:', parseError);
              }

              throw new APIError(errorMessage, response.status, errorData);
            }

            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
              throw new ValidationError('ì˜ëª»ëœ ì‘ë‹µ Content-Type', { contentType });
            }

            const result = await response.json();
            console.log('ë°±ì—”ë“œ ì‘ë‹µ ë°ì´í„°:', result);
            return result;

          } catch (error) {
            if (error instanceof APIError || error instanceof ValidationError) {
              throw error;
            }

            if (error.name === 'TypeError' && error.message.includes('fetch')) {
              throw new NetworkError('ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì‹¤íŒ¨', error);
            }

            if (error.name === 'SyntaxError') {
              throw new ValidationError('ì˜ëª»ëœ JSON ì‘ë‹µ', error);
            }

            throw new NetworkError(`ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${error.message}`, error);
          }
        }, GPT_CONFIG.timeout);
      }

      parseResponse(apiResponse, people = 2) {
        try {
          if (!apiResponse || typeof apiResponse !== 'object') {
            throw new ValidationError('ì‘ë‹µì´ ê°ì²´ê°€ ì•„ë‹˜', apiResponse);
          }

          if (!Array.isArray(apiResponse.menus)) {
            throw new ValidationError('ì‘ë‹µì— menus ë°°ì—´ì´ ì—†ìŒ', apiResponse);
          }

          const normalizedMenus = [];
          apiResponse.menus.slice(0, GPT_CONFIG.maxMenus).forEach((menu, index) => {
            try {
              const normalizedMenu = this.normalizeBackendMenu(menu, people);
              if (normalizedMenu) {
                normalizedMenus.push(normalizedMenu);
              }
            } catch (menuError) {
              console.warn(`ë©”ë‰´ ${index} ì •ê·œí™” ì‹¤íŒ¨, ê±´ë„ˆëœ€:`, menuError);
            }
          });

          return normalizedMenus;

        } catch (error) {
          console.error('ì‘ë‹µ íŒŒì‹± ì˜¤ë¥˜:', error);

          if (error instanceof ValidationError) {
            throw error;
          }

          throw new ValidationError(`ë°±ì—”ë“œ ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨: ${error.message}`, apiResponse);
        }
      }

      generateFallbackMenusFromFavorites(favorites, people) {
        if (!Array.isArray(favorites) || favorites.length === 0) {
          return [];
        }

        console.log(`ë¡œì»¬ fallback ë©”ë‰´ ìƒì„±: ${favorites.length}ê°œ`);

        return favorites.map((rawName, index) => {
          const name = (rawName && typeof rawName === 'string') ? rawName.trim() : '';
          const safeName = name || `ë§ì¶¤ ë©”ë‰´ ${index + 1}`;
          const baseCookingTime = 25 + (index * 5);

          return {
            name: safeName,
            servings: people,
            cookingTime: baseCookingTime,
            ingredients: [
              {
                name: `${safeName} ì£¼ìš” ì¬ë£Œ`,
                qty: Math.max(1, Number(people) || 1),
                unit: 'ì¸ë¶„'
              },
              {
                name: 'ê¸°ë³¸ ì–‘ë…',
                qty: 1,
                unit: 'ì„¸íŠ¸'
              }
            ],
            source: 'gpt',
            origin: 'gpt-fallback'
          };
        });
      }

      normalizeBackendMenu(menu, people) {
        if (!menu || typeof menu !== 'object') {
          throw new ValidationError('ë©”ë‰´ê°€ ê°ì²´ê°€ ì•„ë‹˜', menu);
        }

        const name = typeof menu.name === 'string' ? menu.name.trim() : '';
        if (!name) {
          throw new ValidationError('ë©”ë‰´ ì´ë¦„ ì—†ìŒ', menu);
        }

        const cookingTime = this.validateAndNormalizeNumber(menu.time, 'time', 1, 240, 30);

        const ingredients = Array.isArray(menu.ingredients) ? menu.ingredients : [];
        if (ingredients.length === 0) {
          throw new ValidationError(`ë©”ë‰´ "${name}"ì— ì¬ë£Œê°€ ì—†ìŒ`, menu);
        }

        const normalizedIngredients = ingredients.map((ingredient, index) =>
          this.normalizeIngredient(ingredient, index, people)
        );

        return {
          name,
          servings: people,
          cookingTime,
          ingredients: normalizedIngredients,
          source: 'gpt',
          origin: 'gpt'
        };
      }

      normalizeIngredient(ingredient, index, people) {
        if (!ingredient || typeof ingredient !== 'object') {
          throw new ValidationError(`ì¬ë£Œ ${index}ê°€ ê°ì²´ê°€ ì•„ë‹˜`, ingredient);
        }

        const name = typeof ingredient.name === 'string' ? ingredient.name.trim() : '';
        if (!name) {
          throw new ValidationError(`ì¬ë£Œ ${index}ì— ì´ë¦„ì´ ì—†ìŒ`, ingredient);
        }

        const qtyPerServing = this.validateAndNormalizeNumber(ingredient.qty, 'qty', 0, 10000, 0);
        const totalQty = Number((qtyPerServing * people).toFixed(2));

        const unit = ingredient.unit ? String(ingredient.unit).trim() : '';

        const toNumberOrNull = (value) => {
          if (value === null || value === undefined || value === '') {
            return null;
          }
          const num = Number(value);
          return Number.isFinite(num) ? num : null;
        };

        const pricePerServing = toNumberOrNull(
          ingredient.pricePerServing !== undefined ? ingredient.pricePerServing : ingredient.price
        );

        const directTotalPrice = toNumberOrNull(
          ingredient.totalPrice ?? ingredient.estimatedTotalPrice ?? ingredient.estimatedPrice
        );

        const computedTotalPrice = pricePerServing !== null ? pricePerServing * people : null;
        const totalPrice = directTotalPrice !== null ? directTotalPrice : computedTotalPrice;

        const directUnitPrice = toNumberOrNull(
          ingredient.unitPrice ?? ingredient.estimatedUnitPrice
        );

        const roundedTotalPrice = totalPrice !== null ? Math.round(totalPrice) : null;

        const computedUnitPrice = roundedTotalPrice !== null && totalQty > 0
          ? roundedTotalPrice / totalQty
          : null;

        const unitPriceValue = directUnitPrice !== null ? directUnitPrice : computedUnitPrice;

        const normalized = {
          ...ingredient,
          name,
          qtyPerServing,
          qty: totalQty,
          unit: unit || 'ê°œ'
        };

        if (ingredient.price !== undefined) {
          const parsed = toNumberOrNull(ingredient.price);
          if (parsed !== null) {
            normalized.price = parsed;
          }
        }

        if (ingredient.unitPrice !== undefined) {
          const parsed = toNumberOrNull(ingredient.unitPrice);
          if (parsed !== null) {
            normalized.unitPrice = parsed;
          }
        }

        if (ingredient.totalPrice !== undefined) {
          const parsed = toNumberOrNull(ingredient.totalPrice);
          if (parsed !== null) {
            normalized.totalPrice = parsed;
          }
        }

        if (pricePerServing !== null) {
          normalized.pricePerServing = Math.round(pricePerServing);
          if (normalized.price === undefined) {
            normalized.price = Math.round(pricePerServing);
          }
        }

        if (roundedTotalPrice !== null) {
          normalized.estimatedPrice = roundedTotalPrice;
          if (normalized.totalPrice === undefined) {
            normalized.totalPrice = roundedTotalPrice;
          }
        }

        if (unitPriceValue !== null) {
          const roundedUnit = Number(unitPriceValue.toFixed(2));
          normalized.estimatedUnitPrice = roundedUnit;
          if (normalized.unitPrice === undefined) {
            normalized.unitPrice = roundedUnit;
          }
        }

        if (ingredient.packSize !== undefined) {
          normalized.packSize = Number(ingredient.packSize);
        }

        if (ingredient.packCount !== undefined) {
          normalized.packCount = Number(ingredient.packCount);
        }

        if (ingredient.currency) {
          normalized.currency = String(ingredient.currency);
        }

        return normalized;
      }

      validateAndNormalizeNumber(value, fieldName, min, max, defaultValue) {
        if (value === null || value === undefined || value === '') {
          return defaultValue;
        }

        const num = Number(value);
        if (!Number.isFinite(num)) {
          console.warn(`ì˜ëª»ëœ ${fieldName} ê°’ "${value}", ê¸°ë³¸ê°’ ${defaultValue} ì‚¬ìš©`);
          return defaultValue;
        }

        if (num < min) {
          console.warn(`${fieldName} ê°’ ${num}ì´ ìµœì†Œê°’ ${min}ë³´ë‹¤ ì‘ìŒ, ìµœì†Œê°’ ì‚¬ìš©`);
          return min;
        }

        if (num > max) {
          console.warn(`${fieldName} ê°’ ${num}ì´ ìµœëŒ€ê°’ ${max}ë³´ë‹¤ í¼, ìµœëŒ€ê°’ ì‚¬ìš©`);
          return max;
        }

        return num;
      }

      async checkAPIHealth() {
        const circuitState = this.circuitBreaker.getState();
        const rateLimitStatus = this.rateLimiter.getStatus();

        if (circuitState.state === 'OPEN') {
          const status = {
            available: false,
            reason: `Circuit breakerê°€ ì—´ë¦¼ (ìµœê·¼ ${circuitState.failureCount}íšŒ ì‹¤íŒ¨)`,
            canRetry: false,
            retryAfter: circuitState.timeUntilReset
          };
          this.lastHealthStatus = { ...status, status: 503, timestamp: Date.now() };
          return status;
        }

        if (rateLimitStatus.remainingRequests === 0) {
          const status = {
            available: false,
            reason: 'Rate limit ì´ˆê³¼',
            canRetry: true,
            retryAfter: rateLimitStatus.windowMs
          };
          this.lastHealthStatus = { ...status, status: 429, timestamp: Date.now() };
          return status;
        }

        try {
          const response = await fetch(GPT_CONFIG.healthUrl, {
            method: 'GET',
            mode: 'cors'
          });

          const ok = response.ok;
          const status = {
            available: ok,
            reason: ok ? 'ì •ìƒ' : `HTTP ${response.status}`,
            canRetry: !ok,
            status: response.status
          };

          this.lastHealthStatus = { ...status, timestamp: Date.now() };
          return status;
        } catch (error) {
          const status = {
            available: false,
            reason: `Health check ì‹¤íŒ¨: ${error.message}`,
            canRetry: true,
            status: null
          };
          this.lastHealthStatus = { ...status, timestamp: Date.now() };
          return status;
        }
      }

      getStatus() {
        const circuitState = this.circuitBreaker.getState();
        const rateLimitStatus = this.rateLimiter.getStatus();

        return {
          requestCount: this.requestCount,
          lastRequestTime: this.lastRequestTime,
          circuitBreaker: circuitState,
          rateLimit: rateLimitStatus,
          backend: {
            url: GPT_CONFIG.apiUrl,
            health: this.lastHealthStatus
          },
          config: {
            timeout: GPT_CONFIG.timeout,
            maxRetries: GPT_CONFIG.maxRetries,
            maxMenus: GPT_CONFIG.maxMenus
          }
        };
      }
    }
    // Custom Error Classes
    class APIError extends Error {
      constructor(message, status = 0, originalError = null) {
        super(message);
        this.name = 'APIError';
        this.status = status;
        this.originalError = originalError;
        this.timestamp = new Date().toISOString();
      }
    }

    class ValidationError extends Error {
      constructor(message, data = null) {
        super(message);
        this.name = 'ValidationError';
        this.data = data;
        this.timestamp = new Date().toISOString();
      }
    }

    class NetworkError extends Error {
      constructor(message, originalError = null) {
        super(message);
        this.name = 'NetworkError';
        this.originalError = originalError;
        this.timestamp = new Date().toISOString();
      }
    }

    // Comprehensive Error Handler Utilities
    class GPTErrorHandler {
      static handle(error, fallbackCallback = null) {
        console.error('GPT Backend Error:', error);

        let userMessage = 'ì¶”ì²œ ì„œë¹„ìŠ¤ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
        let messageType = 'error';
        let shouldFallback = true;
        let retryable = false;

        if (error instanceof APIError) {
          switch (error.status) {
            case 400:
              userMessage = 'API ìš”ì²­ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¡œì»¬ ë©”ë‰´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.';
              messageType = 'warning';
              shouldFallback = true;
              retryable = false;
              break;
            case 401:
              userMessage = 'ë°±ì—”ë“œ ì¸ì¦ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë¡œì»¬ ë©”ë‰´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.';
              messageType = 'warning';
              shouldFallback = true;
              retryable = false;
              break;
            case 403:
              userMessage = 'API ì ‘ê·¼ì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. ë¡œì»¬ ë©”ë‰´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.';
              messageType = 'warning';
              shouldFallback = true;
              retryable = false;
              break;
            case 408:
              userMessage = 'API ìš”ì²­ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤. ë¡œì»¬ ë©”ë‰´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.';
              messageType = 'warning';
              shouldFallback = true;
              retryable = true;
              break;
            case 429:
              userMessage = 'API ìš”ì²­ í•œë„ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ê±°ë‚˜ ë¡œì»¬ ë©”ë‰´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.';
              messageType = 'warning';
              shouldFallback = true;
              retryable = true;
              break;
            case 500:
            case 502:
            case 503:
            case 504:
              userMessage = 'ì¶”ì²œ ì„œë¹„ìŠ¤ì— ì¼ì‹œì ì¸ ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤. ë¡œì»¬ ë©”ë‰´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.';
              messageType = 'warning';
              shouldFallback = true;
              retryable = true;
              break;
            default:
              userMessage = `API ì˜¤ë¥˜ (${error.status}): ${error.message}. ë¡œì»¬ ë©”ë‰´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.`;
              messageType = 'warning';
              shouldFallback = true;
              retryable = error.status >= 500;
          }
        } else if (error instanceof NetworkError) {
          userMessage = 'ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì— ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤. ë¡œì»¬ ë©”ë‰´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.';
          messageType = 'warning';
          shouldFallback = true;
          retryable = true;
        } else if (error instanceof ValidationError) {
          userMessage = 'ì¶”ì²œ ì„œë¹„ìŠ¤ ì‘ë‹µ ë°ì´í„°ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¡œì»¬ ë©”ë‰´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.';
          messageType = 'warning';
          shouldFallback = true;
          retryable = false;
        } else if (error.message.includes('API key not configured')) {
          userMessage = 'ì¶”ì²œ ì„œë¹„ìŠ¤ ì„¤ì •ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¡œì»¬ ë©”ë‰´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.';
          messageType = 'info';
          shouldFallback = true;
          retryable = false;
        } else if (error.message.includes('No favorite menus')) {
          userMessage = 'ì„ í˜¸ ë©”ë‰´ê°€ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.';
          messageType = 'info';
          shouldFallback = true;
          retryable = false;
        } else {
          userMessage = `ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}. ë¡œì»¬ ë©”ë‰´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.`;
          messageType = 'error';
          shouldFallback = true;
          retryable = false;
        }

        // Log detailed error information for debugging
        this.logError(error, { userMessage, messageType, shouldFallback, retryable });

        // Show user message using UI manager
        GPTUIManager.showStatusMessage(userMessage, messageType);

        // Execute fallback if available and appropriate
        if (shouldFallback && fallbackCallback) {
          setTimeout(() => {
            GPTUIManager.showStatusMessage('ë¡œì»¬ ë©”ë‰´ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤...', 'info');
            fallbackCallback();
          }, 1500);
        }

        return { userMessage, shouldFallback, retryable };
      }

      static logError(error, context = {}) {
        const errorLog = {
          timestamp: new Date().toISOString(),
          error: {
            name: error.name,
            message: error.message,
            status: error.status || null,
            stack: error.stack
          },
          context,
          userAgent: navigator.userAgent,
          url: window.location.href
        };
        
        console.error('GPT Error Log:', errorLog);
        
        // In a production environment, you might want to send this to a logging service
        // this.sendToLoggingService(errorLog);
      }

      static async withRetry(operation, maxRetries = GPT_CONFIG.maxRetries) {
        let lastError;
        let attempt = 0;
        
        while (attempt <= maxRetries) {
          try {
            const result = await operation();
            
            // Log successful retry if this wasn't the first attempt
            if (attempt > 0) {
              console.log(`GPT API call succeeded on attempt ${attempt + 1}`);
            }
            
            return result;
          } catch (error) {
            lastError = error;
            attempt++;
            
            // Don't retry on certain errors
            if (error instanceof APIError && [400, 401, 403].includes(error.status)) {
              console.log(`Non-retryable error (${error.status}), stopping retry attempts`);
              throw error;
            }
            
            if (error instanceof ValidationError) {
              console.log('Validation error, stopping retry attempts');
              throw error;
            }
            
            if (attempt <= maxRetries) {
              // Calculate delay with exponential backoff and jitter
              const baseDelay = 1000 * Math.pow(2, attempt - 1);
              const jitter = Math.random() * 0.1 * baseDelay; // Add up to 10% jitter
              const delay = Math.min(baseDelay + jitter, 10000); // Cap at 10 seconds
              
              console.log(`GPT API call failed (attempt ${attempt}), retrying in ${Math.round(delay)}ms...`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
        }
        
        console.error(`GPT API call failed after ${maxRetries + 1} attempts`);
        throw lastError;
      }

      static isRetryableError(error) {
        if (error instanceof APIError) {
          // Retry on server errors and rate limiting
          return error.status >= 500 || error.status === 429 || error.status === 408;
        }
        
        if (error instanceof NetworkError) {
          return true;
        }
        
        // Don't retry validation errors or configuration errors
        return false;
      }

      static async withTimeout(operation, timeoutMs = GPT_CONFIG.timeout) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
          controller.abort();
        }, timeoutMs);

        try {
          const result = await operation(controller.signal);
          clearTimeout(timeoutId);
          return result;
        } catch (error) {
          clearTimeout(timeoutId);
          
          if (error.name === 'AbortError') {
            throw new APIError(`Request timeout after ${timeoutMs}ms`, 408, error);
          }
          
          throw error;
        }
      }
    }

    // Global GPT client instance
    window.gptClient = new GPTMenuClient();
    window.GPTErrorHandler = GPTErrorHandler;
    
    // UI State Management for GPT Integration
    class GPTUIManager {
      static getActionButton(){
        return document.getElementById('nextBtn');
      }

      static showLoading(message = 'ì¥ë°”êµ¬ë‹ˆ ìƒì„± ì¤‘...') {
        const resultSection = document.getElementById('resultSection');
        if(resultSection){ resultSection.classList.remove('hidden'); }

        const header = document.getElementById('resultHeader');
        if(header){ header.classList.add('hidden'); }

        const wrap = document.getElementById('resultWrap');
        if(wrap){ wrap.classList.add('hidden'); }

        const indicator = document.getElementById('loadingIndicator');
        const text = document.getElementById('loadingText');

        if (indicator) {
          indicator.classList.remove('hidden');
          if (text) text.textContent = message;
        }

        const actionBtn = this.getActionButton();
        if (actionBtn) {
          if(!actionBtn.dataset.originalContent){
            actionBtn.dataset.originalContent = actionBtn.innerHTML;
          }
          actionBtn.disabled = true;
          actionBtn.innerHTML = message;
        }

        this.hideStatusMessage();
      }

      static hideLoading() {
        const indicator = document.getElementById('loadingIndicator');
        if (indicator) {
          indicator.classList.add('hidden');
        }

        const actionBtn = this.getActionButton();
        if (actionBtn) {
          actionBtn.disabled = false;
          if(actionBtn.dataset.originalContent){
            actionBtn.innerHTML = actionBtn.dataset.originalContent;
          }
        }
      }
      
      static showStatusMessage(message, type = 'info') {
        const statusEl = document.getElementById('statusMessage');
        if (!statusEl) return;
        
        statusEl.textContent = message;
        statusEl.className = `status-message status-${type}`;
        statusEl.classList.remove('hidden');
        
        // Auto-hide success messages after 5 seconds
        if (type === 'success') {
          setTimeout(() => {
            this.hideStatusMessage();
          }, 5000);
        }
      }
      
      static hideStatusMessage() {
        const statusEl = document.getElementById('statusMessage');
        if (statusEl) {
          statusEl.classList.add('hidden');
        }
      }
      
      static showTruncationNotice(originalCount, limitCount) {
        const noticeEl = document.getElementById('favoriteTruncationNotice');
        if (!noticeEl) return;
        
        if (originalCount > limitCount) {
          noticeEl.textContent = `âš ï¸ ì„ í˜¸ ë©”ë‰´ê°€ ${originalCount}ê°œ ì…ë ¥ë˜ì—ˆì§€ë§Œ, ì¶”ì²œ ì—”ì§„ ì œí•œìœ¼ë¡œ ì²˜ìŒ ${limitCount}ê°œë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤.`;
          noticeEl.classList.remove('hidden');
        } else {
          noticeEl.classList.add('hidden');
        }
      }
      
      static hideTruncationNotice() {
        const noticeEl = document.getElementById('favoriteTruncationNotice');
        if (noticeEl) {
          noticeEl.classList.add('hidden');
        }
      }
      
      static revealResults(){
        const header = document.getElementById('resultHeader');
        if(header){ header.classList.remove('hidden'); }
        const wrap = document.getElementById('resultWrap');
        if(wrap){ wrap.classList.remove('hidden'); }
      }

      static updateSubmitButtonForGPT(hasFavorites, needDinner) {
        const actionBtn = this.getActionButton();
        if (!actionBtn) return;

        if (hasFavorites && needDinner) {
          actionBtn.setAttribute('aria-label', 'ì„ í˜¸ ë©”ë‰´ë¥¼ ë°˜ì˜í•´ ì¥ë°”êµ¬ë‹ˆ ë§Œë“¤ê¸°');
          actionBtn.dataset.usesGpt = 'true';
        } else {
          actionBtn.setAttribute('aria-label', 'ì¥ë°”êµ¬ë‹ˆ ë§Œë“¤ê¸°');
          actionBtn.dataset.usesGpt = 'false';
        }
      }
    }
    
    // Graceful Degradation Manager
    class GPTDegradationManager {
      static async attemptGPTWithFallback(operation, fallbackOperation) {
        try {
          // Check API health before attempting
          const healthCheck = await window.gptClient.checkAPIHealth();
          
          if (!healthCheck.available) {
            console.log('GPT backend not available:', healthCheck.reason);
            GPTUIManager.showStatusMessage(
              `ì¶”ì²œ ì„œë¹„ìŠ¤ ì‚¬ìš© ë¶ˆê°€: ${healthCheck.reason}. ë¡œì»¬ ë©”ë‰´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.`,
              'info'
            );
            return await fallbackOperation();
          }

          // Attempt GPT operation
          console.log('Attempting GPT operation...');
          const result = await operation();
          
          // Success - show positive feedback
          GPTUIManager.showStatusMessage('ë§ì¶¤ ë©”ë‰´ ìƒì„±ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
          return result;
          
        } catch (error) {
          console.warn('GPT operation failed, using fallback:', error);
          
          // Handle the error and show appropriate message
          const errorResult = GPTErrorHandler.handle(error);
          
          // Always use fallback when GPT fails
          const fallbackResult = await fallbackOperation();
          
          // Add metadata to indicate fallback was used
          if (Array.isArray(fallbackResult)) {
            fallbackResult.forEach(item => {
              if (item && typeof item === 'object') {
                item.fallbackUsed = true;
                item.originalError = error.message;
              }
            });
          }
          
          return fallbackResult;
        }
      }

      static getSystemStatus() {
        const gptStatus = window.gptClient.getStatus();
        
        return {
          gpt: gptStatus,
          fallbackAvailable: true, // Local database is always available
          recommendedAction: this.getRecommendedAction(gptStatus),
          timestamp: new Date().toISOString()
        };
      }

      static getRecommendedAction(gptStatus) {
        const backendHealth = gptStatus.backend?.health || {};

        if (backendHealth.available === false) {
          return 'Backend API unavailable. Local menu fallback recommended.';
        }

        if (gptStatus.circuitBreaker.state === 'OPEN') {
          const waitTime = Math.ceil(gptStatus.circuitBreaker.timeUntilReset / 1000 / 60);
          return `Recommendation service temporarily unavailable. Will retry in ${waitTime} minutes.`;
        }
        
        if (gptStatus.rateLimit.remainingRequests === 0) {
          return 'Rate limit reached. Please wait before making more requests.';
        }
        
        return 'Recommendation service is available and ready to use';
      }
    }

    // Enhanced UI Manager with detailed status
    GPTUIManager.showDetailedStatus = function(status) {
      const statusEl = document.getElementById('statusMessage');
      if (!statusEl) return;
      
      let message = '';
      let type = 'info';
      
      const backendHealth = status.gpt.backend?.health || {};

      if (status.gpt.circuitBreaker.state === 'OPEN') {
        message = `ğŸ”´ ì¶”ì²œ ì„œë¹„ìŠ¤ê°€ ì¼ì‹œ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤ (${status.gpt.circuitBreaker.failureCount}íšŒ ì‹¤íŒ¨)`;
        type = 'error';
      } else if (status.gpt.rateLimit.remainingRequests === 0) {
        message = 'â³ API ìš”ì²­ í•œë„ ë„ë‹¬, ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”';
        type = 'warning';
      } else if (backendHealth.available === false) {
        message = `âš™ï¸ ì¶”ì²œ ì„œë¹„ìŠ¤ ì˜¤ë¥˜: ${backendHealth.reason || 'ì‚¬ìš© ë¶ˆê°€'}, ë¡œì»¬ ë©”ë‰´ ì‚¬ìš©`;
        type = 'info';
      } else if (backendHealth.available === null) {
        message = 'â„¹ï¸ ì¶”ì²œ ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸ ì¤‘ì…ë‹ˆë‹¤.';
        type = 'info';
      } else {
        message = `âœ… ì¶”ì²œ ì„œë¹„ìŠ¤ ì‚¬ìš© ê°€ëŠ¥ (ë‚¨ì€ ìš”ì²­: ${status.gpt.rateLimit.remainingRequests})`;
        type = 'success';
      }
      
      this.showStatusMessage(message, type);
    };

    // Debug and monitoring utilities
    window.GPTDebug = {
      getSystemStatus: () => GPTDegradationManager.getSystemStatus(),
      
      getErrorStats: () => {
        const status = window.gptClient.getStatus();
        return {
          circuitBreakerState: status.circuitBreaker.state,
          recentFailures: status.circuitBreaker.failureCount,
          rateLimitStatus: status.rateLimit,
          totalRequests: status.requestCount,
          lastRequest: status.lastRequestTime ? new Date(status.lastRequestTime).toLocaleString() : 'Never'
        };
      },
      
      testErrorHandling: async () => {
        console.log('Testing error handling...');
        try {
          // This should trigger various error conditions
          await window.gptClient.generateMenus({ favorites: ['í…ŒìŠ¤íŠ¸ ë©”ë‰´'], people: 2, maxCount: 1 });
        } catch (error) {
          console.log('Expected error caught:', error);
          return GPTErrorHandler.handle(error);
        }
      },
      
      resetCircuitBreaker: () => {
        window.gptClient.circuitBreaker = new GPTCircuitBreaker();
        console.log('Circuit breaker reset');
      },
      
      showStatusPanel: () => {
        const status = GPTDegradationManager.getSystemStatus();
        console.log('=== GPT System Status ===');
        console.log('Backend URL:', status.gpt.backend?.url);
        console.log('Backend Health:', status.gpt.backend?.health);
        console.log('Circuit Breaker:', status.gpt.circuitBreaker.state);
        console.log('Rate Limit:', `${status.gpt.rateLimit.remainingRequests}/${status.gpt.rateLimit.maxRequests}`);
        console.log('Total Requests:', status.gpt.requestCount);
        console.log('Recommended Action:', status.recommendedAction);
        console.log('========================');
        return status;
      }
    };

    // Make managers globally available
    window.GPTUIManager = GPTUIManager;
    window.GPTDegradationManager = GPTDegradationManager;
    
    // Test function for constraint calculation (for development/debugging)
    window.testConstraintCalculation = function() {
      console.log('=== Menu Constraint Calculator Tests ===');
      
      // Test 1: Basic dinner slot calculation
      console.log('Test 1: Basic dinner slot calculation');
      console.log('3 days, no skipped meals:', MenuConstraintCalculator.calculateDinnerSlots(3, [])); // Expected: 3
      console.log('3 days, skip dinner:', MenuConstraintCalculator.calculateDinnerSlots(3, ['ì €ë…'])); // Expected: 0
      console.log('5 days, skip breakfast:', MenuConstraintCalculator.calculateDinnerSlots(5, ['ì•„ì¹¨'])); // Expected: 5
      
      // Test 2: Menu limit determination
      console.log('\nTest 2: Menu limit determination');
      console.log('5 favorites, 3 slots:', MenuConstraintCalculator.determineMenuLimit(5, 3)); // Expected: 3
      console.log('2 favorites, 5 slots:', MenuConstraintCalculator.determineMenuLimit(2, 5)); // Expected: 2
      console.log('4 favorites, 7 slots:', MenuConstraintCalculator.determineMenuLimit(4, 7)); // Expected: 3 (API limit)
      
      // Test 3: Full validation
      console.log('\nTest 3: Full validation');
      const testConstraints = {
        days: 3,
        skipMeals: [],
        favoriteMenus: ['ê¹€ì¹˜ë³¶ìŒë°¥', 'ì œìœ¡ë³¶ìŒ', 'ë‹­ê°€ìŠ´ì‚´ìƒëŸ¬ë“œ', 'ë¶ˆê³ ê¸°', 'ëœì¥ì°Œê°œ']
      };
      const validation = MenuConstraintCalculator.validateMenuConstraints(testConstraints);
      console.log('Validation result:', validation);
      
      // Test 4: Constraint summary
      console.log('\nTest 4: Constraint summary');
      const summary = MenuConstraintCalculator.getConstraintSummary(testConstraints);
      console.log('Summary:', summary);
      
      console.log('=== Tests Complete ===');
      return { validation, summary };
    };

    // Test function for enhanced simulateBackend (for development/debugging)
    window.testSimulateBackend = async function() {
      console.log('=== Testing Enhanced simulateBackend ===');
      
      // Test 1: Basic functionality without favorites
      console.log('Test 1: Basic functionality without favorites');
      const basicAns = {
        days: 3,
        people: 2,
        skipMeals: [],
        favoriteMenu: []
      };
      const basicMenus = await simulateBackend(basicAns);
      console.log('Basic menus count:', basicMenus.length);
      console.log('All menus have local source:', basicMenus.every(m => m.source === 'local'));
      
      // Test 2: With favorite menus (will attempt GPT integration)
      console.log('\nTest 2: With favorite menus');
      const favAns = {
        days: 3,
        people: 2,
        skipMeals: [],
        favoriteMenu: ['ê¹€ì¹˜ë³¶ìŒë°¥', 'ì œìœ¡ë³¶ìŒ']
      };
      const favMenus = await simulateBackend(favAns);
      console.log('Favorite menus count:', favMenus.length);
      console.log('Menu sources:', favMenus.map(m => m.source));
      
      // Test 3: Skip dinner (should not use GPT)
      console.log('\nTest 3: Skip dinner');
      const skipDinnerAns = {
        days: 3,
        people: 2,
        skipMeals: ['ì €ë…'],
        favoriteMenu: ['ê¹€ì¹˜ë³¶ìŒë°¥', 'ì œìœ¡ë³¶ìŒ']
      };
      const skipDinnerMenus = await simulateBackend(skipDinnerAns);
      console.log('Skip dinner menus count:', skipDinnerMenus.length);
      console.log('No dinner menus:', !skipDinnerMenus.some(m => m.title.includes('ì €ë…')));
      
      console.log('=== simulateBackend Tests Complete ===');
    };
  </script>

  <!-- ë©”ë‰´ DB (ë‚´ì¥) -->
  <script>
    const MENU_DB = {
      breakfast: [
        { id:"fried-egg-set", name:"ê³„ë€í›„ë¼ì´ ì •ì‹", time:10,
          ingredients:[{name:"ë°¥",qty:1,unit:"ê³µê¸°"},{name:"ê³„ë€",qty:2,unit:"ê°œ"},{name:"ê¹€ì¹˜",qty:80,unit:"g"}] },
        { id:"kimchi-fried-rice", name:"ê¹€ì¹˜ë³¶ìŒë°¥", time:15,
          ingredients:[{name:"ë°¥",qty:1,unit:"ê³µê¸°"},{name:"ê¹€ì¹˜",qty:120,unit:"g"},{name:"ëŒ€íŒŒ",qty:20,unit:"g"},{name:"ê³„ë€",qty:1,unit:"ê°œ"}] },
        { id:"spinach-soup", name:"ì‹œê¸ˆì¹˜êµ­", time:10,
          ingredients:[{name:"ì‹œê¸ˆì¹˜",qty:100,unit:"g"},{name:"ëŒ€íŒŒ",qty:10,unit:"g"},{name:"ë‘ë¶€",qty:100,unit:"g"}] },
        { id:"cabbage-egg-toast", name:"ì–‘ë°°ì¶”ì—ê·¸í† ìŠ¤íŠ¸", time:8,
          ingredients:[{name:"ì‹ë¹µ",qty:2,unit:"ì¥"},{name:"ê³„ë€",qty:1,unit:"ê°œ"},{name:"ì–‘ë°°ì¶”",qty:50,unit:"g"},{name:"í–„",qty:1,unit:"ì¥"}] },
        { id:"kabocha-porridge", name:"ë‹¨í˜¸ë°•ì£½", time:15,
          ingredients:[{name:"ë‹¨í˜¸ë°•",qty:180,unit:"g"},{name:"ì°¹ìŒ€ê°€ë£¨",qty:20,unit:"g"}] },
        { id:"oatmeal-bowl", name:"ì˜¤íŠ¸ë°€ë³¼", time:5,
          ingredients:[{name:"ì˜¤íŠ¸ë°€",qty:50,unit:"g"},{name:"ìš°ìœ ",qty:200,unit:"ml"},{name:"ë°”ë‚˜ë‚˜",qty:0.5,unit:"ê°œ"}] },
        { id:"tofu-pan", name:"ë‘ë¶€ë¶€ì¹¨", time:10,
          ingredients:[{name:"ë‘ë¶€",qty:180,unit:"g"},{name:"ìª½íŒŒ",qty:10,unit:"g"}] },
      ],
      lunch: [
        { id:"kimchi-jjigae", name:"ê¹€ì¹˜ì°Œê°œ", time:20,
          ingredients:[
          {name:"ê¹€ì¹˜",qty:150,unit:"g"},
          {name:"ë¼ì§€ê³ ê¸° ì•ë‹¤ë¦¬ì‚´",qty:100,unit:"g"},     // â˜… ë³€ê²½
          {name:"ë‘ë¶€",qty:100,unit:"g"},
          {name:"ëŒ€íŒŒ",qty:20,unit:"g"}
        ] },
        { id:"jeyuk-bokkeum", name:"ì œìœ¡ë³¶ìŒ", time:15,
          ingredients:[
            {name:"ë¼ì§€ê³ ê¸° ì•ë‹¤ë¦¬ì‚´",qty:150,unit:"g"},      // â˜… ë³€ê²½(ì œìœ¡ì€ ì•ë‹¤ë¦¬ì‚´/ëª©ì‚´ì´ ì¼ë°˜ì  â†’ ì•ë‹¤ë¦¬ì‚´ë¡œ í†µì¼)
            {name:"ì–‘íŒŒ",qty:50,unit:"g"},
            {name:"ëŒ€íŒŒ",qty:10,unit:"g"}
          ] },
        { id:"doenjang-jjigae", name:"ëœì¥ì°Œê°œ", time:15,
          ingredients:[
            {name:"ë‘ë¶€",qty:120,unit:"g"},
            {name:"ì• í˜¸ë°•",qty:80,unit:"g"},
            {name:"ê°ì",qty:80,unit:"g"},
            {name:"ëŒ€íŒŒ",qty:10,unit:"g"}
          ] },
        { id:"dakbokkeum-tang", name:"ë‹­ë³¶ìŒíƒ•(ê°„ë‹¨)", time:30,
          ingredients:[
            {name:"ë‹­ë‹¤ë¦¬ì‚´(ë³¶ìŒíƒ•ìš© ì ˆë‹¨)",qty:200,unit:"g"},     // â˜… ë³€ê²½
            {name:"ê°ì",qty:100,unit:"g"},
            {name:"ì–‘íŒŒ",qty:50,unit:"g"},
            {name:"ë‹¹ê·¼",qty:40,unit:"g"}
          ] },
        { id:"bibimbap", name:"ë¹„ë¹”ë°¥", time:15,
          ingredients:[
            {name:"ë°¥",qty:1,unit:"ê³µê¸°"},
            {name:"ì‹œê¸ˆì¹˜",qty:80,unit:"g"},
            {name:"ê³ ì‚¬ë¦¬",qty:40,unit:"g"},
            {name:"ê³„ë€",qty:1,unit:"ê°œ"}
          ] },
        { id:"naengmyeon", name:"ëƒ‰ë©´", time:10,
          ingredients:[
            {name:"ëƒ‰ë©´ì‚¬ë¦¬",qty:150,unit:"g"},
            {name:"ì˜¤ì´",qty:40,unit:"g"},
            {name:"ì‚¶ì€ê³„ë€",qty:0.5,unit:"ê°œ"}
          ] },
        { id:"pork-cutlet", name:"ëˆê¹ŒìŠ¤(ê°„ë‹¨)", time:20,
          ingredients:[
            {name:"ë¼ì§€ê³ ê¸° ë“±ì‹¬",qty:120,unit:"g"},          // â˜… ê·¸ëŒ€ë¡œ(ì´ë¯¸ ë¶€ìœ„ ëª…ì‹œ)
            {name:"ë¹µê°€ë£¨",qty:30,unit:"g"},
            {name:"ì–‘ë°°ì¶”",qty:50,unit:"g"}
          ] },
      ],
      dinner: [
        { id:"bulgogi", name:"ë¶ˆê³ ê¸°", time:20,
          ingredients:[
            {name:"ì†Œê³ ê¸° ë¶ˆê³ ê¸°ìš©",qty:150,unit:"g"},        // â˜… ë³€ê²½
            {name:"ì–‘íŒŒ",qty:40,unit:"g"},
            {name:"ë‹¹ê·¼",qty:30,unit:"g"},
            {name:"ëŒ€íŒŒ",qty:10,unit:"g"}
          ] },
        { id:"grilled-mackerel", name:"ê³ ë“±ì–´êµ¬ì´", time:15,
          ingredients:[
            {name:"ê³ ë“±ì–´(ì†ì§ˆ)",qty:150,unit:"g"},
            {name:"ë¬´",qty:80,unit:"g"}
          ] },
        { id:"chicken-salad", name:"ë‹­ê°€ìŠ´ì‚´ìƒëŸ¬ë“œ", time:10,
          ingredients:[
            {name:"ë‹­ê°€ìŠ´ì‚´",qty:120,unit:"g"},
            {name:"ì–‘ìƒì¶”",qty:60,unit:"g"},
            {name:"ë°©ìš¸í† ë§ˆí† ",qty:80,unit:"g"}
          ] },
        { id:"evening-kimchi-fried-rice", name:"ê¹€ì¹˜ë³¶ìŒë°¥(ì €ë…)", time:15,
          ingredients:[
            {name:"ë°¥",qty:1,unit:"ê³µê¸°"},
            {name:"ê¹€ì¹˜",qty:100,unit:"g"},
            {name:"ëŒ€íŒŒ",qty:20,unit:"g"},
            {name:"ê³„ë€",qty:1,unit:"ê°œ"}
          ] },
        { id:"sundubu-jjigae", name:"ìˆœë‘ë¶€ì°Œê°œ", time:20,
          ingredients:[
            {name:"ìˆœë‘ë¶€",qty:200,unit:"g"},
            {name:"ë¼ì§€ê³ ê¸° ì•ë‹¤ë¦¬ì‚´",qty:80,unit:"g"},       // â˜… ë³€ê²½
            {name:"ëŒ€íŒŒ",qty:10,unit:"g"}
          ] },
        { id:"ojingeo-bokkeum", name:"ì˜¤ì§•ì–´ë³¶ìŒ", time:15,
          ingredients:[
            {name:"ì˜¤ì§•ì–´",qty:150,unit:"g"},
            {name:"ì–‘ë°°ì¶”",qty:50,unit:"g"},
            {name:"ì–‘íŒŒ",qty:40,unit:"g"}
          ] },
        { id:"tofu-steak", name:"ë‘ë¶€ìŠ¤í…Œì´í¬", time:15,
          ingredients:[
            {name:"ë‘ë¶€",qty:180,unit:"g"},
            {name:"ì–‘íŒŒ",qty:40,unit:"g"},
            {name:"ë‹¹ê·¼",qty:30,unit:"g"}
          ] },
      ],
    };
  </script>

  <!-- ì¥ë°”êµ¬ë‹ˆ + ë©”ë‰´ ìƒì„± -->
  <script>
    // ====== ë©”ë‰´ & ì¥ë°”êµ¬ë‹ˆ ë¡œì§ ======
    const state = { menus: [], cart: [] };
    const keyOf = (i)=> (i.name + '__' + (i.unit||''));
// ğŸ§© ì´ë¦„ ì •ê·œí™” ë§¤í•‘í‘œ (MENU_DB â†” UNIT_MAP ì¼ì¹˜ìš©)
//  - MENU_DBì˜ ì¬ë£Œëª… ì¤‘ íŒë§¤ë‹¨ìœ„ UNIT_MAP í‚¤ì™€ ë‹¤ë¥¸ ê²ƒë“¤ì„ ëª¨ë‘ ë§¤í•‘
//  - ì´ ë§¤í•‘ì€ mergeCartFromMenus ìœ„ìª½ì— ë„£ì–´ì•¼ í•©ë‹ˆë‹¤.
const NAME_ALIAS = {
  // === ê³µí†µ ê³¡ë¥˜Â·ë°¥ë¥˜ ===
  "ìŒ€": "ìŒ€",
  "ë°¥": "ë°¥",
  "ì‹ë¹µ": "ì‹ë¹µ", // UNIT_MAPì—” ì—†ì§€ë§Œ ê·¸ëŒ€ë¡œ í‘œì‹œ
  "ëƒ‰ë©´ì‚¬ë¦¬": "ëƒ‰ë©´ì‚¬ë¦¬",
  "ë‹¹ë©´": "ë‹¹ë©´",
  "êµ­ìˆ˜": "êµ­ìˆ˜",

  // === ê³„ë€ë¥˜ ===
  "ê³„ë€": "ê³„ë€",
  "ì‚¶ì€ê³„ë€": "ê³„ë€",

  // === ë‘ë¶€ë¥˜ ===
  "ë‘ë¶€": "ë‘ë¶€",
  "ìˆœë‘ë¶€": "ìˆœë‘ë¶€",

  // === ì±„ì†Œë¥˜ ===
  "ëŒ€íŒŒ": "ëŒ€íŒŒ",
  "ìª½íŒŒ": "ìª½íŒŒ",
  "ì–‘íŒŒ": "ì–‘íŒŒ",
  "ê°ì": "ê°ì",
  "ë‹¹ê·¼": "ë‹¹ê·¼",
  "ë¬´": "ë¬´",
  "ì‹œê¸ˆì¹˜": "ì‹œê¸ˆì¹˜",
  "ì• í˜¸ë°•": "ì• í˜¸ë°•",
  "ì–‘ë°°ì¶”": "ì–‘ë°°ì¶”",
  "ì–‘ìƒì¶”": "ì–‘ìƒì¶”",
  "ì–‘ìƒì¶”(ìƒëŸ¬ë“œìš©)": "ì–‘ìƒì¶”",
  "ì˜¤ì´": "ì˜¤ì´",
  "ê³ ì‚¬ë¦¬": "ê³ ì‚¬ë¦¬", // UNIT_MAP ì—†ìŒ
  "ë‹¨í˜¸ë°•": "ë‹¨í˜¸ë°•", // UNIT_MAP ì—†ìŒ
  "ì½©ë‚˜ë¬¼": "ì½©ë‚˜ë¬¼",
  "ìˆ™ì£¼ë‚˜ë¬¼": "ìˆ™ì£¼ë‚˜ë¬¼",
  "ìˆ™ì£¼": "ìˆ™ì£¼ë‚˜ë¬¼",
  "ì²­ê²½ì±„": "ì²­ê²½ì±„",
  "ê¹»ì": "ê¹»ì",
  "ê³ ì¶”": "ê³ ì¶”",
  "í’‹ê³ ì¶”": "ê³ ì¶”",
  "ì²­ì–‘ê³ ì¶”": "ì²­ì–‘ê³ ì¶”",
  "í™ê³ ì¶”": "ê³ ì¶”",
  "ë§ˆëŠ˜": "ë§ˆëŠ˜",
  "ìƒê°•": "ìƒê°•",
  "ë°°ì¶”": "ë°°ì¶”",

  // === ë²„ì„¯ë¥˜ ===
  "ëŠíƒ€ë¦¬ë²„ì„¯": "ëŠíƒ€ë¦¬ë²„ì„¯",
  "ëŠíƒ€ë¦¬": "ëŠíƒ€ë¦¬ë²„ì„¯",
  "ìƒˆì†¡ì´ë²„ì„¯": "ìƒˆì†¡ì´ë²„ì„¯",
  "ìƒˆì†¡ì´": "ìƒˆì†¡ì´ë²„ì„¯",
  "ì–‘ì†¡ì´ë²„ì„¯": "ì–‘ì†¡ì´ë²„ì„¯",
  "ì–‘ì†¡ì´": "ì–‘ì†¡ì´ë²„ì„¯",
  "í‘œê³ ë²„ì„¯": "í‘œê³ ë²„ì„¯",
  "í‘œê³ ": "í‘œê³ ë²„ì„¯",
  "íŒ½ì´ë²„ì„¯": "íŒ½ì´ë²„ì„¯",
  "íŒ½ì´": "íŒ½ì´ë²„ì„¯",

  // === ê³¼ì¼ë¥˜ ===
  "ë°”ë‚˜ë‚˜": "ë°”ë‚˜ë‚˜",
  "ë°©ìš¸í† ë§ˆí† ": "ë°©ìš¸í† ë§ˆí† ",
  "í† ë§ˆí† ": "ë°©ìš¸í† ë§ˆí† ",

  // === ìœ¡ë¥˜ ===
  "ë¼ì§€ê³ ê¸°": "ë¼ì§€ê³ ê¸°",
  "ë¼ì§€ê³ ê¸° ë“±ì‹¬": "ë¼ì§€ê³ ê¸° ë“±ì‹¬",
  "ë¼ì§€ê³ ê¸° ì•ë‹¤ë¦¬": "ë¼ì§€ê³ ê¸°",
  "ë¼ì§€ê³ ê¸° ì•ë‹¤ë¦¬ì‚´": "ë¼ì§€ê³ ê¸°",
  "ë¼ì§€ê³ ê¸° ì‚¼ê²¹ì‚´": "ì‚¼ê²¹ì‚´",
  "ì‚¼ê²¹ì‚´": "ì‚¼ê²¹ì‚´",
  "ì†Œê³ ê¸°": "ì†Œê³ ê¸°",
  "ì†Œê³ ê¸° ë¶ˆê³ ê¸°ìš©": "ì†Œê³ ê¸°",
  "ë‹­": "ë‹­",
  "ë‹­ê³ ê¸°": "ë‹­",
  "ë‹­ê°€ìŠ´ì‚´": "ë‹­ê°€ìŠ´ì‚´",
  "ë‹­ë‹¤ë¦¬ì‚´": "ë‹­ë‹¤ë¦¬ì‚´",
  "ë‹­ë‹¤ë¦¬ì‚´(ë³¶ìŒíƒ•ìš© ì ˆë‹¨)": "ë‹­ë‹¤ë¦¬ì‚´",

  // === ìˆ˜ì‚°ë¬¼ ===
  "ê³ ë“±ì–´": "ê³ ë“±ì–´(ì†ì§ˆ)",
  "ê³ ë“±ì–´(ì†ì§ˆ)": "ê³ ë“±ì–´(ì†ì§ˆ)",
  "ì˜¤ì§•ì–´": "ì˜¤ì§•ì–´",

  // === ì–‘ë…Â·ê°€ê³µì‹í’ˆ ===
  "í–„": "í–„",
  "ë¹µê°€ë£¨": "ë¹µê°€ë£¨",
  "ì°¹ìŒ€ê°€ë£¨": "ì°¹ìŒ€ê°€ë£¨",
  "ì˜¤íŠ¸ë°€": "ì˜¤íŠ¸ë°€",
  "ìš°ìœ ": "ìš°ìœ ",
  "ê¹€ì¹˜": "ê¹€ì¹˜",
  "ë°°ì¶”ê¹€ì¹˜": "ê¹€ì¹˜",
  "ê°„ì¥": "ê°„ì¥",
  "ê³ ì¶§ê°€ë£¨": "ê³ ì¶§ê°€ë£¨",
  "ëœì¥": "ëœì¥",
  "ê³ ì¶”ì¥": "ê³ ì¶”ì¥",
  "ìŒˆì¥": "ìŒˆì¥",
  "ì‹ìš©ìœ ": "ì‹ìš©ìœ ",
  "ì°¸ê¸°ë¦„": "ì°¸ê¸°ë¦„",
  "ì„¤íƒ•": "ì„¤íƒ•",
  "ì†Œê¸ˆ": "ì†Œê¸ˆ",
  "í›„ì¶”": "í›„ì¶”",
  "ë‹¤ì§„ë§ˆëŠ˜": "ë‹¤ì§„ë§ˆëŠ˜",
  "ë§›ìˆ ": "ë§›ìˆ ",
  "ì‹ì´ˆ": "ì‹ì´ˆ",

  // === ê¸°íƒ€ ===
  "ëƒ‰ë©´": "ëƒ‰ë©´ì‚¬ë¦¬",
  "ìˆœì‚´ë‹­": "ë‹­ê°€ìŠ´ì‚´",
  "ìˆœì‚´ë‹­ê°€ìŠ´ì‚´": "ë‹­ê°€ìŠ´ì‚´",
  "ë‘ë¶€ìŠ¤í…Œì´í¬": "ë‘ë¶€",
  "ë‹¨í˜¸ë°•ì£½": "ë‹¨í˜¸ë°•",
  "ë‹¨í˜¸ë°•": "ë‹¨í˜¸ë°•",
  "ë¹„ë¹”ë°¥": "ë°¥",
  "ê¹€ì¹˜ë³¶ìŒë°¥": "ë°¥",
  "ê¹€ì¹˜ë³¶ìŒë°¥(ì €ë…)": "ë°¥",
  "ì‹ë¹µ": "ì‹ë¹µ",
  "ê³ ì‚¬ë¦¬": "ê³ ì‚¬ë¦¬", // UNIT_MAP ì—†ìŒ
};
// í†µí™” í¬ë§·í„°
const KRW = new Intl.NumberFormat("ko-KR",{ style:"currency", currency:"KRW" });

// ë©”ë‰´ëª… â†’ UNIT_MAP í‚¤ë¡œ í•´ì„ + ìŠ¤í™ ë°˜í™˜
function getSpecWithAlias(rawName){
  const key = toUnitMapKey(rawName);
  return { key, spec: (window.UNIT_MAP||{})[key] };
}

// ë©”ë‰´ ë‹¨ìœ„ â†’ íŒë§¤ê¸°ì¤€ ë‹¨ìœ„ë¡œ ë³´ì • (ì˜ˆ: ë°¥ 'ê³µê¸°' â†’ count 'ê°œ')
function normalizeUnitFor(name, unit){
  const key = toUnitMapKey(name);
  
  // ë°¥ ê´€ë ¨
  if(key==="ë°¥" && unit==="ê³µê¸°") return "ê°œ";
  
  // ë¬´ê²Œ ë‹¨ìœ„ ì •ê·œí™”
  if(unit==="kg") return "g";  // kgë¥¼ gë¡œ ë³€í™˜
  if(unit==="ê·¸ë¨") return "g";
  
  // ë¶€í”¼ ë‹¨ìœ„ ì •ê·œí™”
  if(unit==="L" || unit==="ë¦¬í„°") return "ml";
  if(unit==="cc") return "ml";
  if(unit==="í°ìˆ ") return "ml";  // 1í°ìˆ  = ì•½ 15mlë¡œ ê³„ì‚° í•„ìš”ì‹œ
  if(unit==="ì‘ì€ìˆ " || unit==="í‹°ìŠ¤í‘¼") return "ml";  // 1ì‘ì€ìˆ  = ì•½ 5ml
  
  // ê°œìˆ˜ ë‹¨ìœ„ ì •ê·œí™”
  if(unit==="ê°œì…" || unit==="ì…" || unit==="ea") return "ê°œ";
  if(unit==="ë§ˆë¦¬") return "ê°œ";
  if(unit==="ì¤Œ") return "ê°œ";  // ì¤Œì€ ê°œìˆ˜ë¡œ ì²˜ë¦¬
  if(unit==="ì¥") return "ê°œ";
  if(unit==="ì¡°ê°") return "ê°œ";
  if(unit==="í†µ") return "ê°œ";
  if(unit==="ë¿Œë¦¬") return "ê°œ";
  if(unit==="ì•Œ") return "ê°œ";
  
  return unit || "";
}

// í–‰ ì†Œê³„ ê³„ì‚° (packCeil ë¡œ ì˜¬ë¦¼ í›„ ê°€ê²© ê³±)
function calcItemPrice(rawName, unit, baseQty){
  const { key, spec } = getSpecWithAlias(rawName);
  if(!spec) return { ok:false, reason:"NO_SPEC" };

  const normUnit = normalizeUnitFor(rawName, unit);
  const unitOk =
    (spec.base==="weight" && normUnit==="g") ||
    (spec.base==="volume" && normUnit==="ml") ||
    (spec.base==="count"  && normUnit==="ê°œ");

  if(!unitOk) return { ok:false, reason:"UNIT_MISMATCH" };

  const { packSize, totalBase } = window.packCeil(key, Number(baseQty||0));
  const u = (spec.sell||[]).find(s => s.size===packSize);
  if(!u || typeof u.price!=="number") return { ok:false, reason:"NO_PRICE" };

  const packs = packSize>0 ? Math.round(totalBase/packSize) : 0;
  return { ok:true, packs, unitPrice:u.price, subtotal: packs*u.price, keyUsed:key };
}

// ì´í•© ê³„ì‚°
function calcCartTotal(items){
  let total=0, missing=[];
  for(const it of items){
    const r = calcItemPrice(it.name, it.unit, it.qty);
    if(r.ok){
      total += r.subtotal;
    }else if(typeof it.estimatedPrice === 'number' && Number.isFinite(it.estimatedPrice)){
      total += Number(it.estimatedPrice);
    }else{
      missing.push({name:it.name, reason:r.reason});
    }
  }
  return { total, missing };
}


// ğŸ§© ë©”ë‰´ í•­ëª© ì´ë¦„ì„ íŒë§¤ë‹¨ìœ„ ì´ë¦„ìœ¼ë¡œ ë³€í™˜
function toUnitMapKey(name) {
  return NAME_ALIAS[name] || name;
}

const IMAGE_MAP = {
  "ê°ˆì¹˜": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/e224ef34a410f.png",
  "ê°ì": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/faaf4324fabd2.png",
  "ê³„ë€": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/8ac26d36d7d9f.png",
  "ê¹€": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/773f7ba41aa5b.png",
  "ê¹»ì": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/487118f505606.png",
  "ëŠíƒ€ë¦¬ë²„ì„¯": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/0377601364ed4.png",
  "ë‹¤ì‹œë§ˆ": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/ba8cb258f31a6.png",
  "ë‹­ê°€ìŠ´ì‚´": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/7e62d740a1328.png",
  "ë‹­ë‹¤ë¦¬ì‚´": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/bd80c22d3b365.png",
  "ë‹¹ê·¼": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/a00a644c29db2.png",
  "ëŒ€íŒŒ": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/a8c134c26ae69.png",
  "ë‘ë¶€": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/e071adb636571.png",
  "ë–¡êµ­ë–¡": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/177da34f48bd4.png",
  "ë§ˆëŠ˜": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/12be130ddff2e.png",
  "ë©¸ì¹˜": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/3f81c1cc57891.png",
  "ë¯¸ì—­": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/e9d468823f0d7.png",
  "ê¹€ì¹˜": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/f828a52631108.png",
  "ì†Œê³ ê¸°": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/325c6b21117e2.png",
  "ë¼ì§€ê³ ê¸°": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/6f3d2a62e0512.png",
  "ìˆœë‘ë¶€": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/907fc1ea38634.png",
  "ì‹œê¸ˆì¹˜": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/e0317ad7d9cff.png",
  "ì‹ë¹µ": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/9e4ed59a7a715.png",
  "ìŒ€": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/55b4f21d4888c.png",
  "ì• í˜¸ë°•": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/6ffaa8e4b6e37.png",
  "ì–‘íŒŒ": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/e01ad839feaf7.png",
  "ì˜¤ì§•ì–´": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/f46d2179b9d44.png",
  "ì°¸ê¹¨": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/2714a21737307.png",
  "ì°¸ì¹˜": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/7272e45449ccf.png",
  "ì²­ì–‘ê³ ì¶”": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/c8c066de9b5c8.png",
  "ì½©ë‚˜ë¬¼": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/f86ddae307d8d.png",
  "íŒ½ì´ë²„ì„¯": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/e08007c1fcfae.png",
  "ê³ ë“±ì–´(ì†ì§ˆ)": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/3074975216231.png",
  "ëƒ‰ë©´ì‚¬ë¦¬": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/f8382e23c9f8e.png",
  "ë¬´": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/8d22795c5171f.png",
  "ë°”ë‚˜ë‚˜":"https://cdn.imweb.me/upload/S202510104a8ac458dba6c/c69dbf78bbec7.png",
  "ë°¥": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/bd5e4601f4784.png",
  "ë¹µê°€ë£¨": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/36539aeb723cd.png",
  "ì–‘ë°°ì¶”": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/80b1e118b2b1a.png",
  "ì–‘ìƒì¶”": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/8e801d54145cd.png",
  "ì˜¤ì´": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/f03d17831fe3c.png",
  "ì˜¤íŠ¸ë°€": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/47224bb5b099e.png",
  "ìš°ìœ ": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/2067e0146e7dd.png",
  "ìª½íŒŒ": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/e668248ff267e.png",
  "ì°¹ìŒ€ê°€ë£¨": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/26127274d57b6.png",
  "ë°©ìš¸í† ë§ˆí† ": "https://cdn.imweb.me/upload/S202510104a8ac458dba6c/2ece365c5a6bc.png",
};

// ì´ë¦„ ì •ê·œí™”í•˜ì—¬ ì´ë¯¸ì§€ ì°¾ê¸° (ì—¬ë¶„ ê³µë°±/ë³„ì¹­ê¹Œì§€ ì¼€ì–´)
function getImageUrl(rawName) {
  if (!rawName) return null;
  const name = String(rawName).replace(/\s+/g, " ").trim(); // ë‹¤ì¤‘ ê³µë°± ì •ë¦¬
  // 1) ì •í™• ì¼ì¹˜
  if (IMAGE_MAP[name]) return IMAGE_MAP[name];
  // 2) ë³„ì¹­ í›„ ì¬ì‹œë„
  const aliased = toUnitMapKey(name);
  if (IMAGE_MAP[aliased]) return IMAGE_MAP[aliased];
  // 3) ê³µë°± ì œê±° ë¹„êµ(ì˜ˆ: 'ëŠíƒ€ë¦¬ë²„ì„¯' vs 'ëŠíƒ€ë¦¬ ë²„ì„¯')
  const compact = name.replace(/\s+/g, "");
  for (const k of Object.keys(IMAGE_MAP)) {
    if (k.replace(/\s+/g, "") === compact) return IMAGE_MAP[k];
  }
  return null; // ì—†ìœ¼ë©´ null
}

    function mergeCartFromMenus(menus){
  const map = new Map();

  // 1) í•©ì‚°
  for (const m of menus) {
    for (const raw of (m.ingredients || [])) {
      const k = (raw.name + '__' + (raw.unit || ''));

      const toNumberOrNull = (value) => {
        if (value === null || value === undefined || value === '') {
          return null;
        }
        const num = Number(value);
        return Number.isFinite(num) ? num : null;
      };

      const qtyValue = Number(raw.qty || 0);
      const qty = Number.isFinite(qtyValue) ? qtyValue : 0;

      const estimatedPrice = toNumberOrNull(raw.estimatedPrice ?? raw.totalPrice);
      const estimatedUnitPrice = toNumberOrNull(raw.estimatedUnitPrice ?? raw.unitPrice);
      const pricePerServing = toNumberOrNull(raw.pricePerServing ?? raw.price);

      if (!map.has(k)) {
        const base = { ...raw, qty };

        if (estimatedPrice !== null) {
          base.estimatedPrice = Math.round(estimatedPrice);
        }

        if (estimatedUnitPrice !== null) {
          base.estimatedUnitPrice = Number(estimatedUnitPrice.toFixed(2));
        } else if (estimatedPrice !== null && qty > 0) {
          base.estimatedUnitPrice = Number((estimatedPrice / qty).toFixed(2));
        }

        if (pricePerServing !== null) {
          base.pricePerServing = Math.round(pricePerServing);
        }

        map.set(k, base);
      } else {
        const acc = map.get(k);
        acc.qty = Number(acc.qty || 0) + qty;

        if (estimatedPrice !== null) {
          const current = toNumberOrNull(acc.estimatedPrice) || 0;
          acc.estimatedPrice = Math.round(current + estimatedPrice);
        }

        if (acc.estimatedPrice !== undefined && Number(acc.qty) > 0) {
          acc.estimatedUnitPrice = Number((acc.estimatedPrice / acc.qty).toFixed(2));
        }

        if (pricePerServing !== null) {
          acc.pricePerServing = Math.round(pricePerServing);
        }
      }
    }
  }

  // 2) í•©ì‚° í›„ â†’ íŒë§¤ë‹¨ìœ„ ì˜¬ë¦¼(ceil)
  const out = [];
  for (const it of map.values()) {
    const nameKey = toUnitMapKey(it.name);
const spec = (window.UNIT_MAP || {})[nameKey];
const normUnit = normalizeUnitFor(it.name, it.unit);

const supported =
  spec &&
  ((spec.base === "weight" && normUnit === "g") ||
   (spec.base === "volume" && normUnit === "ml") ||
   (spec.base === "count"  && normUnit === "ê°œ"));

if (supported && typeof window.packCeil === "function") {
  const { totalBase } = window.packCeil(nameKey, Number(it.qty || 0));
  const next = { ...it, name: nameKey, unit: normUnit, qty: totalBase };
  if (typeof next.estimatedUnitPrice === 'number' && Number.isFinite(next.estimatedUnitPrice)) {
    next.estimatedPrice = Math.round(next.estimatedUnitPrice * totalBase);
  }
  out.push(next);
} else {
  const next = { ...it, unit: normUnit };
  if (typeof next.estimatedUnitPrice === 'number' && Number.isFinite(next.estimatedUnitPrice) && Number.isFinite(Number(next.qty))) {
    next.estimatedPrice = Math.round(next.estimatedUnitPrice * Number(next.qty));
  }
  out.push(next);
}

  }

  // 3) ì •ë ¬
  return out.sort(
    (a, b) =>
      (a.category || '').localeCompare(b.category || '') ||
      a.name.localeCompare(b.name)
  );
}

    function renderMenus(){
      const box = document.getElementById('menusBox'); if(!box) return; box.innerHTML='';
      if(!state.menus.length){ box.textContent='ë©”ë‰´ê°€ ì—†ìŠµë‹ˆë‹¤.'; return; }
      const list=document.createElement('div'); list.style.display='grid'; list.style.gap='10px';
      state.menus.forEach((m,idx)=>{
        const row=document.createElement('div'); row.className='tr'; row.style.gridTemplateColumns='1.4fr .6fr 1fr auto';
        
        // Create source badge
        const sourceBadge = m.source === 'gpt' 
          ? '<span class="menu-source-badge menu-source-gpt">ğŸ¤– ë§ì¶¤</span>'
          : '<span class="menu-source-badge menu-source-local">ğŸ“š ê¸°ë³¸</span>';
        
        row.innerHTML =
          '<div><strong>'+m.title+'</strong> '+sourceBadge+'<div class="small muted">ì£¼ìš” ì¬ë£Œ: '+(m.ingredients||[]).slice(0,3).map(i=>i.name).join(', ')+((m.ingredients||[]).length>3?' ë“±':'')+'</div></div>'+
          '<div>ì¸ë¶„: <strong>'+m.servings+'</strong></div>'+
          '<div>ì¬ë£Œìˆ˜: <strong>'+((m.ingredients&&m.ingredients.length)||0)+'</strong></div>'+
          '<div style="text-align:right"><button class="icon-btn" data-rm-menu="'+idx+'">ğŸ—‘ï¸ ë©”ë‰´ ì œì™¸</button></div>';
        list.appendChild(row);
      });
      box.appendChild(list);
      box.querySelectorAll('[data-rm-menu]').forEach(btn=> btn.addEventListener('click', e=>{
        const i = Number(e.currentTarget.getAttribute('data-rm-menu'));
        state.menus.splice(i,1);
        state.cart = mergeCartFromMenus(state.menus);
        drawAll();
      }));
    }

    function renderCart(){
  const box=document.getElementById('cartBox'); if(!box) return;
  const q = (document.getElementById('cartSearch') && document.getElementById('cartSearch').value || '').trim().toLowerCase();
  let items = state.cart.slice();
  if(q) items = items.filter(it => (it.name||'').toLowerCase().indexOf(q)>-1);
  if(!items.length){ box.innerHTML='<div class="muted">ì¥ë°”êµ¬ë‹ˆê°€ ë¹„ì—ˆê±°ë‚˜ ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>'; return; }

  const head=document.createElement('div');
  head.className='th';
  head.textContent='ì¬ë£Œ / ìˆ˜ëŸ‰ / ë‹¨ìœ„ / ê¸ˆì•¡ / ì‘ì—…';

  const wrap=document.createElement('div'); wrap.style.display='grid'; wrap.style.gap='8px';

  // ì§€ì› ê°€ëŠ¥í•œ í•­ëª©ì¸ì§€(íŒë§¤ë‹¨ìœ„ ì ìš© ê°€ëŠ¥) ì²´í¬
  const isSellEnabled = (it)=>{
  const { spec } = getSpecWithAlias(it.name);
  const unit = normalizeUnitFor(it.name, it.unit);
  if(!spec) return false;
  if(spec.base==="weight" && unit==="g") return true;
  if(spec.base==="volume" && unit==="ml") return true;
  if(spec.base==="count"  && unit==="ê°œ") return true;
  return false;
};


  const updateEstimatedPriceForItem = (item) => {
    if (typeof item.estimatedUnitPrice === 'number' && Number.isFinite(item.estimatedUnitPrice)) {
      const qty = Number(item.qty || 0);
      if (Number.isFinite(qty)) {
        item.estimatedPrice = Math.round(item.estimatedUnitPrice * qty);
      }
    }
  };


  items.forEach((it,idx)=>{
  const supported = isSellEnabled(it);
  const friendly = supported ? window.formatForDisplay(it.name, Number(it.qty||0)) : '';
  const img = (typeof getImageUrl === 'function') ? getImageUrl(it.name) : null;
  const imgHTML = img ? `<img src="${img}" alt="${it.name}" class="thumb" loading="lazy">` : '';

  const priceInfo = calcItemPrice(it.name, it.unit, it.qty);
  const priceHTML = priceInfo.ok
    ? `<div><strong>${KRW.format(priceInfo.subtotal)}</strong><div class="small muted">${priceInfo.packs}íŒ© Ã— ${KRW.format(priceInfo.unitPrice)}</div></div>`
    : `<div class="small muted">ê°€ê²©ì •ë³´ ì—†ìŒ</div>`;

  const row=document.createElement('div'); row.className='tr';
  row.style.gridTemplateColumns='1.2fr .8fr .6fr .8fr auto';
  
  row.innerHTML =
    `<div class="inline">
       ${imgHTML}
       <div>
         <strong>${it.name}</strong>
         <div class="small muted">
           ${friendly ? friendly : (it.category||'ê¸°íƒ€')}
         </div>
       </div>
     </div>
     <div>
       <div class="inline" style="gap:6px">
         <button class="icon-btn" data-dec="${idx}">âˆ’</button>
         <input data-qty="${idx}" type="number" min="0" step="0.1"
                value="${Number(it.qty||0)}" style="max-width:110px"/>
         <button class="icon-btn" data-inc="${idx}">ï¼‹</button>
       </div>
     </div>
     <div>${it.unit||''}</div>
     <div>${priceHTML}</div>
     <div style="text-align:right"><button class="icon-btn" data-remove="${idx}">ì œê±°</button></div>`;

  wrap.appendChild(row);
});


  const totals = calcCartTotal(items);
  const footer = document.createElement('div');
  footer.className='tr';
  footer.style.gridTemplateColumns='1fr auto';
  footer.innerHTML =
    `<div><strong>í•©ê³„</strong>${totals.missing.length ? ` <span class="small muted">(+ê°€ê²©ì •ë³´ ì—†ìŒ ${totals.missing.length}ê±´)</span>` : ''}</div>
     <div style="text-align:right"><strong style="font-size:18px">${KRW.format(totals.total)}</strong></div>`;

  box.innerHTML=''; 
  box.appendChild(head); 
  box.appendChild(wrap); 
  box.appendChild(footer);

  // + ë²„íŠ¼: íŒë§¤ë‹¨ìœ„ ìŠ¤í… ì ìš©
  box.querySelectorAll('[data-inc]').forEach(b=> b.addEventListener('click', e=>{
    const i=Number(e.currentTarget.getAttribute('data-inc'));
    const it = state.cart[i];
    const spec = (window.UNIT_MAP||{})[it.name];
    const supported = spec && (
      (spec.base==="weight" && it.unit==="g") ||
      (spec.base==="volume" && it.unit==="ml") ||
      (spec.base==="count"  && it.unit==="ê°œ")
    );
    if(supported){
      it.qty = window.nudgeByStep(it.name, Number(it.qty||0), true);
    }else{
      it.qty = Number(it.qty||0)+1; // ê¸°ì¡´ fallback
    }
    updateEstimatedPriceForItem(it);
    drawAll();
  }));

  // âˆ’ ë²„íŠ¼: íŒë§¤ë‹¨ìœ„ ìŠ¤í… + íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ì ìš©
  box.querySelectorAll('[data-dec]').forEach(b=> b.addEventListener('click', e=>{
    const i=Number(e.currentTarget.getAttribute('data-dec'));
    const it = state.cart[i];
    const spec = (window.UNIT_MAP||{})[it.name];
    const supported = spec && (
      (spec.base==="weight" && it.unit==="g") ||
      (spec.base==="volume" && it.unit==="ml") ||
      (spec.base==="count"  && it.unit==="ê°œ")
    );
    if(supported){
      it.qty = window.nudgeByStep(it.name, Number(it.qty||0), false);
    }else{
      it.qty = Math.max(0, Number(it.qty||0)-1);
    }
    updateEstimatedPriceForItem(it);
    drawAll();
  }));

  // ì§ì ‘ ì…ë ¥ ì‹œ: ê°€ëŠ¥í•œ ê²½ìš° íŒë§¤ë‹¨ìœ„ë¡œ ceil ìŠ¤ëƒ…
  box.querySelectorAll('[data-qty]').forEach(inp=> inp.addEventListener('change', e=>{
    const i=Number(e.currentTarget.getAttribute('data-qty'));
    const it = state.cart[i];
    const v = Number(e.currentTarget.value);
    const sanitized = Number.isFinite(v)? v: 0;
    const spec = (window.UNIT_MAP||{})[it.name];
    const supported = spec && (
      (spec.base==="weight" && it.unit==="g") ||
      (spec.base==="volume" && it.unit==="ml") ||
      (spec.base==="count"  && it.unit==="ê°œ")
    );
    if(supported){
      const packed = window.packCeil(it.name, sanitized);
      it.qty = packed.totalBase;
    }else{
      it.qty = sanitized;
    }
    updateEstimatedPriceForItem(it);
    drawAll();
  }));

  // ì œê±°
  box.querySelectorAll('[data-remove]').forEach(b=> b.addEventListener('click', e=>{
    const i=Number(e.currentTarget.getAttribute('data-remove'));
    state.cart.splice(i,1);
    drawAll();
  }));
}

  function drawAll(){ renderMenus(); renderCart(); }

  // íˆ´ë°”
  if(document.getElementById('cartSearch')) document.getElementById('cartSearch').addEventListener('input', ()=> renderCart());

    // === Menu Constraint Calculator ===
    class MenuConstraintCalculator {
      /**
       * Calculate available dinner slots based on days and skipped meals
       * @param {number} days - Number of days for meal planning
       * @param {Array<string>} skipMeals - Array of meal types to skip (e.g., ["ì•„ì¹¨", "ì ì‹¬"])
       * @returns {number} Number of available dinner slots
       */
      static calculateDinnerSlots(days, skipMeals = []) {
        const skipSet = new Set(skipMeals);
        const needDinner = !skipSet.has("ì €ë…");
        
        if (!needDinner) {
          return 0;
        }
        
        return Math.max(0, days);
      }

      /**
       * Determine maximum menu count based on business rules
       * @param {number} favoriteCount - Number of favorite menus provided by user
       * @param {number} availableSlots - Number of available dinner slots
       * @returns {number} Maximum number of menus to generate (min of 3, favorite count, available slots)
       */
      static determineMenuLimit(favoriteCount, availableSlots) {
        // Business rule: Maximum 3 menus from GPT API
        const maxApiMenus = 3;
        
        // Apply constraints: min of (3, favorite count, available slots)
        return Math.min(maxApiMenus, favoriteCount, availableSlots);
      }

      /**
       * Validate menu limits and user input constraints
       * @param {Object} constraints - Object containing validation parameters
       * @param {number} constraints.days - Number of days
       * @param {Array<string>} constraints.skipMeals - Meals to skip
       * @param {Array<string>} constraints.favoriteMenus - User's favorite menus
       * @returns {Object} Validation result with isValid flag and details
       */
      static validateMenuConstraints(constraints) {
        const { days, skipMeals = [], favoriteMenus = [] } = constraints;
        
        const validation = {
          isValid: true,
          errors: [],
          warnings: [],
          calculations: {}
        };

        // Validate days
        if (!days || days < 1 || days > 7) {
          validation.isValid = false;
          validation.errors.push('Days must be between 1 and 7');
        }

        // Calculate dinner slots
        const dinnerSlots = this.calculateDinnerSlots(days, skipMeals);
        validation.calculations.dinnerSlots = dinnerSlots;

        // Check if dinner is completely skipped
        if (dinnerSlots === 0) {
          validation.warnings.push('No dinner slots available - ë§ì¶¤ ë©”ë‰´ê°€ ìƒì„±ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
        }

        // Validate favorite menus
        const favoriteCount = favoriteMenus.length;
        validation.calculations.favoriteCount = favoriteCount;

        if (favoriteCount === 0) {
          validation.warnings.push('No favorite menus provided - will use local database only');
        }

        // Calculate menu limit
        const menuLimit = this.determineMenuLimit(favoriteCount, dinnerSlots);
        validation.calculations.menuLimit = menuLimit;

        // Check if favorite menus exceed limit
        if (favoriteCount > 3) {
          validation.warnings.push(`Only first 3 favorite menus will be sent to the recommendation engine (provided: ${favoriteCount})`);
        }

        // Check if available slots limit menu generation
        if (favoriteCount > dinnerSlots && dinnerSlots > 0) {
          validation.warnings.push(`Limited to ${dinnerSlots} menus due to available dinner slots (favorites: ${favoriteCount})`);
        }

        return validation;
      }

      /**
       * Get constraint summary for display purposes
       * @param {Object} constraints - Constraint parameters
       * @returns {Object} Summary object with key metrics
       */
      static getConstraintSummary(constraints) {
        const validation = this.validateMenuConstraints(constraints);
        
        return {
          totalDays: constraints.days,
          dinnerSlots: validation.calculations.dinnerSlots,
          favoriteMenusProvided: validation.calculations.favoriteCount,
          maxGPTMenus: validation.calculations.menuLimit,
          willUseFallback: validation.calculations.menuLimit < validation.calculations.favoriteCount || validation.calculations.dinnerSlots === 0,
          hasWarnings: validation.warnings.length > 0,
          warnings: validation.warnings
        };
      }
    }

    // Make MenuConstraintCalculator globally available for testing
    window.MenuConstraintCalculator = MenuConstraintCalculator;

    // === Enhanced Backend with GPT Integration ===
    async function simulateBackend(ans) {
      const days = Math.max(1, Number(ans?.days || 1));
      const people = Math.max(1, Number(ans?.people || 2));
      const skip = new Set(ans?.skipMeals || []);
      const favs = ans?.favoriteMenu || [];

      const needBreakfast = !skip.has("ì•„ì¹¨");
      const needLunch = !skip.has("ì ì‹¬");
      const needDinner = !skip.has("ì €ë…");

      // Create base plan using local database
      const basePlan = createBasePlan(days, people, skip, favs);
      
      // Check if we have favorite menus to process with GPT
      if (favs && favs.length > 0 && needDinner) {
        // Calculate constraints for GPT integration
        const dinnerSlots = MenuConstraintCalculator.calculateDinnerSlots(days, Array.from(skip));
        const menuLimit = MenuConstraintCalculator.determineMenuLimit(favs.length, dinnerSlots);
        
        if (menuLimit > 0) {
          // Limit favorite menus to calculated maximum
          const favoriteSubset = favs.slice(0, menuLimit);
          
          console.log(`Attempting GPT menu generation for ${favoriteSubset.length} favorite menus`);
          
          // Use graceful degradation manager for GPT operation with fallback
          return await GPTDegradationManager.attemptGPTWithFallback(
            // GPT operation
            async () => {
              const gptMenus = await window.gptClient.generateMenus({
                favorites: favoriteSubset,
                people,
                days,
                maxCount: menuLimit,
                skipMeals: Array.from(skip),
                includeIngredientPrices: true
              });
              
              if (gptMenus && gptMenus.length > 0) {
                console.log(`Successfully generated ${gptMenus.length} GPT menus`);
                return scheduleGPTMenus(basePlan, gptMenus, days, skip);
              } else {
                throw new ValidationError('GPT API returned no valid menus');
              }
            },
            // Fallback operation
            async () => {
              console.log('Using local database fallback');
              return basePlan;
            }
          );
        } else {
          console.log('No dinner slots available for GPT menus, using local database only');
          GPTUIManager.showStatusMessage('ì €ë… ìŠ¬ë¡¯ì´ ì—†ì–´ ë§ì¶¤ ë©”ë‰´ë¥¼ ì ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'info');
        }
      } else if (favs && favs.length > 0 && !needDinner) {
        console.log('Favorite menus provided but dinner is skipped, using local database only');
        GPTUIManager.showStatusMessage('ì €ë…ì„ ê±´ë„ˆë›°ì–´ ì„ í˜¸ ë©”ë‰´ë¥¼ ì ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'info');
      }
      
      // Return base plan if no GPT integration needed
      return basePlan;
    }

    // Helper function to create base meal plan using local database
    function createBasePlan(days, people, skip, favs) {
      const needBreakfast = !skip.has("ì•„ì¹¨");
      const needLunch = !skip.has("ì ì‹¬");
      const needDinner = !skip.has("ì €ë…");

      const favNorm = favs.map(s => s.replace(/\s+/g,'').toLowerCase());
      const reorder = (list) => {
        if (!favNorm.length) return list.slice();
        return list.slice().sort((a, b) => {
          const aHit = favNorm.some(f => a.name.replace(/\s+/g,'').toLowerCase().includes(f));
          const bHit = favNorm.some(f => b.name.replace(/\s+/g,'').toLowerCase().includes(f));
          return (aHit===bHit)?0:(aHit?-1:1);
        });
      };

      const bList = reorder(MENU_DB.breakfast);
      const lList = reorder(MENU_DB.lunch);
      const dList = reorder(MENU_DB.dinner);

      const plan = [];
      for (let d = 0; d < days; d++) {
        if (needBreakfast) plan.push({ meal:'ì•„ì¹¨', dish: bList[d % bList.length] });
        if (needLunch)     plan.push({ meal:'ì ì‹¬', dish: lList[d % lList.length] });
        if (needDinner)    plan.push({ meal:'ì €ë…', dish: dList[d % dList.length] });
      }

      const menus = plan.map(({ meal, dish }) => ({
        title: `${meal} Â· ${dish.name}`,
        servings: people,
        time: dish.time,
        source: 'local', // Mark as local database menu
        ingredients: dish.ingredients.map(it => ({
          name: it.name,
          unit: it.unit,
          qty: Number((it.qty * people).toFixed(1)),
          category: it.category || undefined
        }))
      }));

      return menus;
    }

    // Helper function to schedule GPT menus into dinner slots
    function scheduleGPTMenus(basePlan, gptMenus, days, skipMeals) {
      const skipSet = new Set(skipMeals);
      const needDinner = !skipSet.has("ì €ë…");
      
      if (!needDinner || !gptMenus || gptMenus.length === 0) {
        return basePlan;
      }

      // Find dinner slot indices in the base plan
      const dinnerIndices = [];
      let dayCounter = 0;
      let mealInDay = 0;
      
      for (let i = 0; i < basePlan.length; i++) {
        const menu = basePlan[i];
        if (menu.title.includes('ì €ë…')) {
          dinnerIndices.push(i);
        }
      }

      // Replace dinner slots with GPT menus starting from day 1
      const enhancedPlan = [...basePlan];
      for (let i = 0; i < Math.min(gptMenus.length, dinnerIndices.length); i++) {
        const dinnerIndex = dinnerIndices[i];
        const gptMenu = gptMenus[i];
        
        // Replace the dinner slot with GPT menu
        enhancedPlan[dinnerIndex] = {
          title: `ì €ë… Â· ${gptMenu.name}`,
          servings: gptMenu.servings,
          time: gptMenu.cookingTime || gptMenu.time || 30,
          source: gptMenu.source || 'gpt', // Preserve GPT origin metadata
          origin: gptMenu.origin || gptMenu.source || 'gpt',
          ingredients: gptMenu.ingredients.map(it => {
            const toNumberOrNull = (value) => {
              if (value === null || value === undefined || value === '') {
                return null;
              }
              const num = Number(value);
              return Number.isFinite(num) ? num : null;
            };

            const qtyValue = Number(it.qty);
            const qty = Number.isFinite(qtyValue) ? qtyValue : 0;

            const perServingPrice = toNumberOrNull(it.pricePerServing ?? it.price);
            const totalServings = toNumberOrNull(gptMenu.servings) ?? 1;
            const directTotalPrice = toNumberOrNull(it.estimatedPrice ?? it.totalPrice);
            const totalPrice = directTotalPrice !== null
              ? directTotalPrice
              : (perServingPrice !== null ? perServingPrice * totalServings : null);

            const roundedTotalPrice = totalPrice !== null ? Math.round(totalPrice) : null;

            const directUnitPrice = toNumberOrNull(it.estimatedUnitPrice ?? it.unitPrice);
            const unitPrice = directUnitPrice !== null
              ? directUnitPrice
              : (roundedTotalPrice !== null && qty > 0 ? roundedTotalPrice / qty : null);

            const ingredient = {
              name: it.name,
              unit: it.unit,
              qty,
              category: it.category || undefined
            };

            if (perServingPrice !== null) {
              ingredient.pricePerServing = Math.round(perServingPrice);
            }

            if (roundedTotalPrice !== null) {
              ingredient.estimatedPrice = roundedTotalPrice;
            }

            if (unitPrice !== null) {
              ingredient.estimatedUnitPrice = Number(unitPrice.toFixed(2));
            }

            return ingredient;
          })
        };
      }

      return enhancedPlan;
    }

    async function handleSubmit(){
      const ans = (typeof getAnswers==='function') ? getAnswers() : {};
      renderSummary();

      const hasFavorites = ans?.favoriteMenu && ans.favoriteMenu.length > 0;
      const skipSet = new Set(ans?.skipMeals || []);
      const needDinner = !skipSet.has("ì €ë…");
      const usesGpt = hasFavorites && needDinner;

      GPTUIManager.showLoading('ì¥ë°”êµ¬ë‹ˆ ìƒì„± ì¤‘...');

      try{
        const menus = await simulateBackend(ans);
        state.menus = menus;
        state.cart = mergeCartFromMenus(state.menus);
        drawAll();

        GPTUIManager.hideLoading();
        GPTUIManager.revealResults();

        const resultSection = document.getElementById('resultSection');
        if(resultSection){
          resultSection.classList.remove('hidden');
          resultSection.scrollIntoView({ behavior:'smooth', block:'start' });
        }

        const header = document.getElementById('resultHeader');
        if(header){
          header.classList.remove('hidden');
          const title = header.querySelector('h2');
          if(title){ title.textContent = 'âœ… ì¥ë°”êµ¬ë‹ˆê°€ ì¤€ë¹„ë˜ì—ˆì–´ìš”!'; }
        }

        const gptMenuCount = menus.filter(menu => menu.source === 'gpt').length;
        const gptFallbackCount = menus.filter(menu => menu.origin === 'gpt-fallback').length;
        const localMenuCount = menus.filter(menu => menu.source === 'local').length;

        let message;
        let type = 'success';

        if (gptFallbackCount > 0) {
          message = `â„¹ï¸ ì¥ë°”êµ¬ë‹ˆê°€ ì¤€ë¹„ë˜ì—ˆì–´ìš”! ì„œë²„ ì‘ë‹µì´ ì§€ì—°ë˜ì–´ ì„ í˜¸ ë©”ë‰´ ${gptFallbackCount}ê°œë¥¼ ë¡œì»¬ì—ì„œ êµ¬ì„±í–ˆì–´ìš”. ${localMenuCount}ê°œì˜ ê¸°ë³¸ ë©”ë‰´ë„ í•¨ê»˜ ë‹´ì•˜ì–´ìš”.`;
          type = 'info';
        } else if (gptMenuCount > 0) {
          message = `âœ… ì¥ë°”êµ¬ë‹ˆê°€ ì¤€ë¹„ë˜ì—ˆì–´ìš”! ${gptMenuCount}ê°œì˜ ë§ì¶¤ ë©”ë‰´ì™€ ${localMenuCount}ê°œì˜ ê¸°ë³¸ ë©”ë‰´ë¥¼ ë‹´ì•˜ì–´ìš”.`;
        } else if (usesGpt) {
          message = 'âš ï¸ ì„ í˜¸ ë©”ë‰´ë¥¼ ë°˜ì˜í•˜ì§€ ëª»í•´ ê¸°ë³¸ ì¶”ì²œ ë©”ë‰´ë¡œ ì±„ì› ì–´ìš”.';
          type = 'warning';
        } else {
          message = `âœ… ì¥ë°”êµ¬ë‹ˆê°€ ì¤€ë¹„ë˜ì—ˆì–´ìš”! ${localMenuCount}ê°œì˜ ì¶”ì²œ ë©”ë‰´ë¥¼ ì¤€ë¹„í–ˆì–´ìš”.`;
        }

        GPTUIManager.showStatusMessage(message, type);
      }catch(e){
        GPTUIManager.hideLoading();
        GPTUIManager.showStatusMessage('âŒ ë©”ë‰´ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
        console.error(e);
      }
    }
  </script>
<script>
/* === grocery-units.js (browser) === */
(function(){
  const HYST = 0.97;

  function fmtTrimZeros(v, unit){ const s=(Math.round(v*10)/10).toFixed(1); return (s.endsWith(".0")? s.slice(0,-2): s)+unit; }
  function formatWeight(g){ return g>=1000 ? fmtTrimZeros(g/1000,"kg") : Math.round(g)+"g"; }
  function formatVolume(ml){ return ml>=1000 ? fmtTrimZeros(ml/1000,"L") : Math.round(ml)+"ml"; }
  function isTrayLike(label){ return /ê°œì…/.test(label); }
  function hasLeadingOneCounter(label){ return /^1[ê°€-í£]/.test(label); }
  function extractParenContent(label){ const m=label.match(/\(([^)]+)\)/); return m? m[1]: null; }

  window.UNIT_MAP = {
     "ìŒ€":{base:"weight",displayKind:"bag",
      sell:[{size:1000,label:"1kg",price:3000},{size:4000,label:"4kg",price:11000},{size:10000,label:"10kg",price:26000},{size:20000,label:"20kg",price:50000}]
    },
    "ë°¥":{base:"count",displayKind:"instant",uiStep:3,
      sell:[{size:3,label:"ì¦‰ì„ë°¥ 3ì…",price:3300},{size:6,label:"ì¦‰ì„ë°¥ 6ì…",price:6200},{size:12,label:"ì¦‰ì„ë°¥ 12ì…",price:12000}]
    },
    "ê³„ë€":{base:"count",displayKind:"tray",uiStep:10,
      sell:[{size:10,label:"10ê°œì…",price:5500},{size:15,label:"15ê°œì…",price:7500},{size:30,label:"30ê°œì…",price:13000}]
    },
    "ê°ì":{base:"weight",displayKind:"bag",uiStep:1000,approxPiecesPerPack:"1kgâ‰ˆ5~6ê°œ",
      sell:[{size:1000,label:"1kg",price:2500},{size:2000,label:"2kg",price:4800},{size:3000,label:"3kg",price:7000},{size:5000,label:"5kg",price:11500}]
    },
    "ë‹¹ê·¼":{base:"weight",displayKind:"bag",uiStep:1000,approxPiecesPerPack:"1kgâ‰ˆ5~6ê°œ",
      sell:[{size:1000,label:"1kg",price:2200},{size:2000,label:"2kg",price:4300},{size:3000,label:"3kg",price:6300},{size:5000,label:"5kg",price:10000}]
    },
    "ë¬´":{base:"weight",displayKind:"whole",uiStep:2000,approxPiecesPerPack:"1í†µâ‰ˆ2kg",
      sell:[{size:2000,label:"1í†µ(â‰ˆ2kg)",price:2000},{size:4000,label:"2í†µ",price:3800}]
    },
    "ì–‘íŒŒ":{base:"weight",displayKind:"bag",uiStep:1000,approxPiecesPerPack:"1kgâ‰ˆ4~5ê°œ",
      sell:[{size:1000,label:"1kg",price:2000},{size:2000,label:"2kg",price:3800},{size:3000,label:"3kg",price:5600}]
    },
    "ì–‘ë°°ì¶”":{base:"weight",displayKind:"whole",uiStep:500,
      sell:[{size:500,label:"1/4í†µ(â‰ˆ500g)",price:900},{size:1000,label:"1/2í†µ",price:1700},{size:2000,label:"1í†µ",price:3200}]
    },
    "ì–‘ìƒì¶”":{base:"weight",displayKind:"whole",uiStep:450,
      sell:[{size:450,label:"1í†µ(â‰ˆ450g)",price:2200}]
    },
    "ì‹œê¸ˆì¹˜":{base:"weight",displayKind:"bunch",uiStep:350,
      sell:[{size:350,label:"1ë‹¨(â‰ˆ350g)",price:2000}]
    },
    "ê³ ì‚¬ë¦¬":{base:"weight",displayKind:"bag",uiStep:100,
      sell:[{size:100,label:"1ë´‰(100g)",price:2500},{size:200,label:"1ë´‰(200g)",price:4500}]
    },
    "ëŒ€íŒŒ":{base:"weight",displayKind:"bunch",uiStep:350,
      sell:[{size:350,label:"1ë‹¨(â‰ˆ350g)",price:2000},{size:200,label:"ì†ì§ˆ 200g",price:1600}]
    },
    "ìª½íŒŒ":{base:"weight",displayKind:"bunch",uiStep:300,
      sell:[{size:300,label:"1ë‹¨(â‰ˆ300g)",price:1800}]
    },
    "ì˜¤ì´":{base:"weight",displayKind:"piece",uiStep:100,
      sell:[{size:600,label:"3ì…(â‰ˆ600g)",price:2300},{size:1000,label:"5ì…(â‰ˆ1kg)",price:3600}],
      approxPiecesPerPack:"3ì…â‰ˆ3ê°œ"
    },
    "ë°”ë‚˜ë‚˜":{base:"count",displayKind:"piece",uiStep:6,
      sell:[{size:6,label:"1ì†¡ì´(6ê°œë‚´ì™¸)",price:3200}]
    },
    "ë°©ìš¸í† ë§ˆí† ":{base:"weight",displayKind:"pack",uiStep:500,
      sell:[{size:500,label:"1íŒ©(500g)",price:3000},{size:1000,label:"1kg",price:5600}]
    },

    /* ê³ ê¸°/ìƒì„  */
    "ë¼ì§€ê³ ê¸°":{base:"weight",displayKind:"pack",uiStep:400,
      sell:[{size:300,label:"1íŒ©(300g)",price:3300},{size:400,label:"1íŒ©(400g)",price:4200},{size:500,label:"1íŒ©(500g)",price:5200}]
    },
    "ë¼ì§€ê³ ê¸° ë“±ì‹¬":{base:"weight",displayKind:"pack",uiStep:400,
      sell:[{size:400,label:"1íŒ©(400g/3~4ì¥)",price:5500}]
    },
    "ì†Œê³ ê¸°":{base:"weight",displayKind:"pack",uiStep:400,
      sell:[{size:300,label:"1íŒ©(300g)",price:6500},{size:400,label:"1íŒ©(400g)",price:8500}]
    },
    "ë‹­ê°€ìŠ´ì‚´":{base:"weight",displayKind:"pack",uiStep:500,
      sell:[{size:500,label:"1íŒ©(500g)",price:5000},{size:1000,label:"1kg",price:9500}]
    },
    "ë‹­":{base:"weight",displayKind:"whole",uiStep:1000,
      sell:[{size:1000,label:"1ë§ˆë¦¬(â‰ˆ1kg)",price:7500}]
    },
    "ê³ ë“±ì–´(ì†ì§ˆ)":{base:"weight",displayKind:"pack",uiStep:150,
      sell:[{size:150,label:"1íŒ©(150g/1ë§ˆë¦¬)",price:3000},{size:300,label:"2ë§ˆë¦¬íŒ©(300g)",price:5500},{size:500,label:"1íŒ©(500g)",price:9000}]
    },
    "ì˜¤ì§•ì–´":{base:"weight",displayKind:"pack",uiStep:150,
      sell:[{size:150,label:"1íŒ©(150g/1ë§ˆë¦¬)",price:3500},{size:300,label:"2ë§ˆë¦¬íŒ©(300g)",price:6500},{size:450,label:"3ë§ˆë¦¬íŒ©(450g)",price:9000}]
    },

    /* ê°€ê³µ/ìœ ì œí’ˆ */
    "ë‘ë¶€":{base:"weight",displayKind:"block",uiStep:350,
      sell:[{size:350,label:"1ëª¨(350g)",price:2000}]
    },
    "ìˆœë‘ë¶€":{base:"weight",displayKind:"pack",uiStep:400,
      sell:[{size:400,label:"1íŒ©(400g)",price:1800}]
    },
    "ë¹µê°€ë£¨":{base:"weight",displayKind:"bag",uiStep:200,
      sell:[{size:200,label:"1ë´‰(200g)",price:1500},{size:500,label:"1ë´‰(500g)",price:3200}]
    },
    "í–„":{base:"count",displayKind:"pack",uiStep:6,
      sell:[{size:6,label:"1íŒ©(6ì¥)",price:3500},{size:10,label:"1íŒ©(10ì¥)",price:5500}]
    },
    "ì˜¤íŠ¸ë°€":{base:"weight",displayKind:"bag",uiStep:400,
      sell:[{size:400,label:"1ë´‰(400g)",price:3500},{size:1000,label:"1kg",price:7500}]
    },
    "ì°¹ìŒ€ê°€ë£¨":{base:"weight",displayKind:"bag",uiStep:300,
      sell:[{size:300,label:"1ë´‰(300g)",price:2200},{size:500,label:"1ë´‰(500g)",price:3200},{size:1000,label:"1kg",price:5800}]
    },
    "ìš°ìœ ":{base:"volume",displayKind:"bottle",uiStep:1000,
      sell:[{size:1000,label:"1L",price:2500},{size:1800,label:"1.8L",price:4400}]
    },
    "ê¹€ì¹˜":{base:"weight",displayKind:"pack",uiStep:500,
      sell:[{size:500,label:"1íŒ©(500g)",price:4000},{size:1000,label:"1kg",price:7500}]
    },

    /* ì¶”ê°€ ì±„ì†Œ */
    "ì½©ë‚˜ë¬¼":{base:"weight",displayKind:"bag",uiStep:300,
      sell:[{size:300,label:"1ë´‰(300g)",price:1200},{size:500,label:"1ë´‰(500g)",price:1800}]
    },
    "ìˆ™ì£¼ë‚˜ë¬¼":{base:"weight",displayKind:"bag",uiStep:300,
      sell:[{size:300,label:"1ë´‰(300g)",price:1500},{size:500,label:"1ë´‰(500g)",price:2200}]
    },
    "ì• í˜¸ë°•":{base:"weight",displayKind:"piece",uiStep:400,approxPiecesPerPack:"1ê°œâ‰ˆ400g",
      sell:[{size:400,label:"1ê°œ(â‰ˆ400g)",price:1500},{size:800,label:"2ê°œ",price:2800}]
    },
    "ì²­ê²½ì±„":{base:"weight",displayKind:"bunch",uiStep:300,
      sell:[{size:300,label:"1ë‹¨(â‰ˆ300g)",price:1800}]
    },
    "ê¹»ì":{base:"weight",displayKind:"pack",uiStep:50,
      sell:[{size:50,label:"1íŒ©(50g/ì•½30ì¥)",price:2000},{size:100,label:"1íŒ©(100g)",price:3500}]
    },
    "ê³ ì¶”":{base:"weight",displayKind:"bag",uiStep:100,
      sell:[{size:100,label:"1ë´‰(100g)",price:1500},{size:200,label:"1ë´‰(200g)",price:2800}]
    },
    "ì²­ì–‘ê³ ì¶”":{base:"weight",displayKind:"bag",uiStep:100,
      sell:[{size:100,label:"1ë´‰(100g)",price:1800},{size:200,label:"1ë´‰(200g)",price:3200}]
    },
    "ë§ˆëŠ˜":{base:"weight",displayKind:"bag",uiStep:200,
      sell:[{size:200,label:"ê¹ë§ˆëŠ˜ 200g",price:2500},{size:500,label:"ê¹ë§ˆëŠ˜ 500g",price:5500},{size:1000,label:"ê¹ë§ˆëŠ˜ 1kg",price:10000}]
    },
    "ìƒê°•":{base:"weight",displayKind:"bag",uiStep:100,
      sell:[{size:100,label:"1ë´‰(100g)",price:1500},{size:200,label:"1ë´‰(200g)",price:2800},{size:500,label:"1ë´‰(500g)",price:6000}]
    },
    "ë°°ì¶”":{base:"weight",displayKind:"whole",uiStep:2000,
      sell:[{size:2000,label:"1í¬ê¸°(â‰ˆ2kg)",price:3000},{size:4000,label:"2í¬ê¸°",price:5800}]
    },

    /* ë²„ì„¯ë¥˜ */
    "ëŠíƒ€ë¦¬ë²„ì„¯":{base:"weight",displayKind:"pack",uiStep:150,
      sell:[{size:150,label:"1íŒ©(150g)",price:1500},{size:300,label:"1íŒ©(300g)",price:2800}]
    },
    "ìƒˆì†¡ì´ë²„ì„¯":{base:"weight",displayKind:"pack",uiStep:200,
      sell:[{size:200,label:"1íŒ©(200g)",price:2000},{size:400,label:"1íŒ©(400g)",price:3800}]
    },
    "ì–‘ì†¡ì´ë²„ì„¯":{base:"weight",displayKind:"pack",uiStep:200,
      sell:[{size:200,label:"1íŒ©(200g)",price:2200},{size:400,label:"1íŒ©(400g)",price:4000}]
    },
    "í‘œê³ ë²„ì„¯":{base:"weight",displayKind:"pack",uiStep:100,
      sell:[{size:100,label:"1íŒ©(100g)",price:2500},{size:200,label:"1íŒ©(200g)",price:4500}]
    },
    "íŒ½ì´ë²„ì„¯":{base:"weight",displayKind:"pack",uiStep:150,
      sell:[{size:150,label:"1ë´‰(150g)",price:1000},{size:300,label:"2ë´‰",price:1900}]
    },

    /* ìœ¡ë¥˜ ì¶”ê°€ */
    "ë‹­ë‹¤ë¦¬ì‚´":{base:"weight",displayKind:"pack",uiStep:500,
      sell:[{size:500,label:"1íŒ©(500g)",price:5500},{size:1000,label:"1kg",price:10500}]
    },
    "ì‚¼ê²¹ì‚´":{base:"weight",displayKind:"pack",uiStep:500,
      sell:[{size:500,label:"1íŒ©(500g)",price:6500},{size:1000,label:"1kg",price:12500}]
    },

    /* ë©´ë¥˜ */
    "ëƒ‰ë©´ì‚¬ë¦¬":{base:"weight",displayKind:"pack",uiStep:150,
      sell:[{size:150,label:"1ì¸ë¶„(150g)",price:1500},{size:300,label:"2ì¸ë¶„(300g)",price:2500},{size:600,label:"4ì¸ë¶„(600g)",price:4500}]
    },
    "ì‹ë¹µ":{base:"count",displayKind:"pack",uiStep:10,
      sell:[{size:10,label:"1ë´‰(10ì¥)",price:3500},{size:20,label:"1ë´‰(20ì¥)",price:6500}]
    },
    "ë‹¨í˜¸ë°•":{base:"weight",displayKind:"piece",uiStep:500,approxPiecesPerPack:"1ê°œâ‰ˆ500g",
      sell:[{size:500,label:"1ê°œ(â‰ˆ500g)",price:3500},{size:1000,label:"1í†µ(â‰ˆ1kg)",price:6500}]
    },
    "ë‹¹ë©´":{base:"weight",displayKind:"bag",uiStep:100,
      sell:[{size:100,label:"1ë´‰(100g)",price:1200},{size:500,label:"1ë´‰(500g)",price:4500}]
    },
    "êµ­ìˆ˜":{base:"weight",displayKind:"bag",uiStep:400,
      sell:[{size:400,label:"1ë´‰(400g)",price:2500},{size:1000,label:"1kg",price:5500}]
    },

    /* ì–‘ë… ë° ì†ŒìŠ¤ */
    "ê°„ì¥":{base:"volume",displayKind:"bottle",uiStep:500,
      sell:[{size:500,label:"500ml",price:3500},{size:930,label:"930ml",price:6000},{size:1800,label:"1.8L",price:10000}]
    },
    "ê³ ì¶§ê°€ë£¨":{base:"weight",displayKind:"bag",uiStep:100,
      sell:[{size:100,label:"1ë´‰(100g)",price:2500},{size:500,label:"1ë´‰(500g)",price:10000},{size:1000,label:"1kg",price:18000}]
    },
    "ëœì¥":{base:"weight",displayKind:"tub",uiStep:500,
      sell:[{size:500,label:"1í†µ(500g)",price:4000},{size:1000,label:"1kg",price:7500}]
    },
    "ê³ ì¶”ì¥":{base:"weight",displayKind:"tub",uiStep:500,
      sell:[{size:500,label:"1í†µ(500g)",price:4500},{size:1000,label:"1kg",price:8000}]
    },
    "ìŒˆì¥":{base:"weight",displayKind:"tub",uiStep:500,
      sell:[{size:500,label:"1í†µ(500g)",price:3500}]
    },
    "ì‹ìš©ìœ ":{base:"volume",displayKind:"bottle",uiStep:900,
      sell:[{size:900,label:"900ml",price:4500},{size:1800,label:"1.8L",price:8000}]
    },
    "ì°¸ê¸°ë¦„":{base:"volume",displayKind:"bottle",uiStep:160,
      sell:[{size:160,label:"160ml",price:5500},{size:320,label:"320ml",price:10000}]
    },
    "ì„¤íƒ•":{base:"weight",displayKind:"bag",uiStep:500,
      sell:[{size:500,label:"1ë´‰(500g)",price:1800},{size:1000,label:"1kg",price:3200},{size:3000,label:"3kg",price:8500}]
    },
    "ì†Œê¸ˆ":{base:"weight",displayKind:"bag",uiStep:500,
      sell:[{size:500,label:"1ë´‰(500g)",price:1500},{size:1000,label:"1kg",price:2500},{size:3000,label:"3kg",price:6500}]
    },
    "í›„ì¶”":{base:"weight",displayKind:"bottle",uiStep:30,
      sell:[{size:30,label:"1ë³‘(30g)",price:2500},{size:100,label:"1ë³‘(100g)",price:7000}]
    },
    "ë‹¤ì§„ë§ˆëŠ˜":{base:"weight",displayKind:"bottle",uiStep:200,
      sell:[{size:200,label:"1ë³‘(200g)",price:3000},{size:500,label:"1ë³‘(500g)",price:6500}]
    },
    "ë§›ìˆ ":{base:"volume",displayKind:"bottle",uiStep:500,
      sell:[{size:500,label:"500ml",price:2500},{size:1000,label:"1L",price:4500}]
    },
    "ì‹ì´ˆ":{base:"volume",displayKind:"bottle",uiStep:500,
      sell:[{size:500,label:"500ml",price:2000},{size:900,label:"900ml",price:3500}]
    }
  };

  function getSpec(ing){
    const spec = window.UNIT_MAP[ing];
    return spec || { base:"count", sell:[{size:1,label:"1ê°œ"}], uiStep:1, displayKind:"piece" };
  }
  function getStepSize(spec){ return spec.uiStep ?? spec.sell[0].size; }

  function packCeilInternal(ingName, required){
    const spec = getSpec(ingName);
    const sells = spec.sell;
    if(required<=0) return { unit:sells[0], multiple:0, totalBase:0 };
    let bestUnit = sells[0], bestMul = Math.max(1, Math.ceil(required/sells[0].size));
    let bestTotal = bestMul * bestUnit.size;
    for(const u of sells){
      const m = Math.max(1, Math.ceil(required / u.size));
      const t = m*u.size;
      if(t < bestTotal){ bestUnit=u; bestMul=m; bestTotal=t; }
    }
    return { unit:bestUnit, multiple:bestMul, totalBase:bestTotal };
  }

  function packFloorByStep(ingName, current){
    const spec = getSpec(ingName);
    const step = getStepSize(spec);
    const mul = Math.floor(current/step);
    return { stepSize:step, multiple:mul, totalBase: mul*step };
  }

  function nudgeByStep(ingName, current, plus){
    const spec = getSpec(ingName);
    const step = getStepSize(spec);
    if(plus){
      const nextRaw = current + step;
      return packCeilInternal(ingName, nextRaw).totalBase;
    }else{
      const nextRaw = Math.max(0, current - step);
      const floor = packFloorByStep(ingName, current);
      const curPackBase = floor.totalBase;
      const downBase = Math.max(0, curPackBase - step);
      if(curPackBase===0) return 0;
      if(nextRaw < HYST * curPackBase) return downBase;
      return curPackBase;
    }
  }

  function packCeil(ingName, required){
    const {unit, multiple, totalBase} = packCeilInternal(ingName, required);
    const spec = getSpec(ingName);
    let packLabel = unit.label;
    if(multiple>1){
      if(spec.base==="weight"||spec.base==="volume"||isTrayLike(unit.label)){
        packLabel = `${unit.label} x ${multiple}`;
      }else if(hasLeadingOneCounter(unit.label)){
        packLabel = unit.label.replace(/^1([ê°€-í£]+)/, `${multiple}$1`);
      }else{
        packLabel = `${unit.label} x ${multiple}`;
      }
    }
    return { packLabel, packSize: unit.size, totalBase };
  }

  function formatForDisplay(ingName, baseQty){
    const spec = getSpec(ingName);
    const {unit, multiple, totalBase} = packCeilInternal(ingName, baseQty);
    let mainLabel = unit.label;
    if(multiple>1){
      if(spec.base==="weight"||spec.base==="volume"||isTrayLike(unit.label)){
        mainLabel = `${unit.label} x ${multiple}`;
      }else if(hasLeadingOneCounter(unit.label)){
        mainLabel = unit.label.replace(/^1([ê°€-í£]+)/, `${multiple}$1`);
      }else{
        mainLabel = `${unit.label} x ${multiple}`;
      }
    }
    const parts=[];
    const paren = extractParenContent(unit.label);
    if(multiple>1){
      if(paren){ parts.push(`(${paren} x ${multiple})`); }
      else{
        if(spec.base==="weight") parts.push(`(${formatWeight(unit.size)} x ${multiple})`);
        else if(spec.base==="volume") parts.push(`(${formatVolume(unit.size)} x ${multiple})`);
        else if(spec.base==="count") parts.push(`(${unit.size}ê°œ x ${multiple})`);
      }
    }
    if(spec.approxPiecesPerPack){
      const tip = spec.approxPiecesPerPack.split("â‰ˆ")[1] || spec.approxPiecesPerPack;
      if(multiple<=1) parts.push(`(ì•½ ${tip})`);
      else parts.push(`(ì•½ ${tip}/íŒ©)`);
    }
    if(ingName==="ê³„ë€"){
      const surplus = totalBase - baseQty;
      if(surplus>0) parts.push(`(ë‚¨ìŒ ${Math.round(surplus)}ê°œ ì—¬ìœ )`);
    }
    const tail = parts.length? " "+parts.join(" ") : "";
    return `${ingName} ${mainLabel}${tail}`;
  }

  // expose
  window.nudgeByStep = nudgeByStep;
  window.packCeil = packCeil;
  window.formatForDisplay = formatForDisplay;
})();

</script>

</body>
</html>